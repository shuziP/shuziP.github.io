<!DOCTYPE html>





<html class="theme-next mist" lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="generator" content="Hexo 3.9.0">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.3.0">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.3.0">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.3.0">
  <link rel="mask-icon" href="/images/logo.svg?v=7.3.0" color="#222">

<link rel="stylesheet" href="/css/main.css?v=7.3.0">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">


<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '7.3.0',
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    search: {
      root: '/',
      path: ''
    },
    tabs: true,
    motion: {"enable":false,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: 'Kopieren',
      copy_success: 'Kopiert',
      copy_failure: 'Kopieren fehlgeschlagen'
    }
  };
</script>

  <meta name="description" content="对计算机而言，能够“看到”的是图像被编码之后的数字，但它很难解高层语义概念，比如图像或者视频帧中出现目标的是人还是物体，更无法定位目标出现在图像中哪个区域。目标检测的主要目的是让计算机可以自动识别图片或者视频帧中所有目标的类别，并在该目标周围绘制边界框，标示出每个目标的位置，如 图1 所示。">
<meta property="og:type" content="article">
<meta property="og:title" content="目标检测PaddlePaddleYOLO-V3">
<meta property="og:url" content="https://github.com/shuziP/shuzip.github.io.git/2020/06/26/技术/PaddlePaddleYOLO-V3/index.html">
<meta property="og:site_name" content="shuzip">
<meta property="og:description" content="对计算机而言，能够“看到”的是图像被编码之后的数字，但它很难解高层语义概念，比如图像或者视频帧中出现目标的是人还是物体，更无法定位目标出现在图像中哪个区域。目标检测的主要目的是让计算机可以自动识别图片或者视频帧中所有目标的类别，并在该目标周围绘制边界框，标示出每个目标的位置，如 图1 所示。">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://ai-studio-static-online.cdn.bcebos.com/e25116d994724f83abe3bef7f033c1c89bf34e083075494bb7833947c557f4fc">
<meta property="og:image" content="https://ai-studio-static-online.cdn.bcebos.com/d131c45973a244c590c3d1ee3866a694b134299542284b22b794e4ab76c4769d">
<meta property="og:image" content="https://ai-studio-static-online.cdn.bcebos.com/57755ac8e95a460f9262afc7c37a0db51f66027ff86c40e2967a2e22524c20a1">
<meta property="og:image" content="https://ai-studio-static-online.cdn.bcebos.com/f581e1bfd07a414596368c9c03a1b30ea115a2e30a014be68b2c26961f5c38fa">
<meta property="og:image" content="https://github.com/shuziP/shuzip.github.io.git/2020/06/26/技术/PaddlePaddleYOLO-V3/output_4_1.png">
<meta property="og:image" content="https://ai-studio-static-online.cdn.bcebos.com/1eaa96c6dd8149f59665d80384ba189eb9f4c9bcc5ef47a79027385cbac033a0">
<meta property="og:image" content="https://ai-studio-static-online.cdn.bcebos.com/50bbb215ee9d4c048fd8788e2828ec7694199c6eadf746dfb9a7b83c79c17a45">
<meta property="og:image" content="https://ai-studio-static-online.cdn.bcebos.com/4befa4f120ca48a1a41986bf5542abb8ec136a1545214264bbf78e315cfb03f9">
<meta property="og:image" content="https://ai-studio-static-online.cdn.bcebos.com/c21075a2450c4f64a2e52d3179a95c96d065c6a84ec344bb969fd4cac22df980">
<meta property="og:image" content="https://ai-studio-static-online.cdn.bcebos.com/2dd1cbeb53644552a8cb38f3f834dbdda5046a489465454d93cdc88d1ce65ca5">
<meta property="og:image" content="https://ai-studio-static-online.cdn.bcebos.com/6dd42b9138364a379b6231ac2247d3cb449d612e17be4896986bca2703acbb29">
<meta property="og:image" content="https://ai-studio-static-online.cdn.bcebos.com/0880c3b5ec2d40edb476f4fcbadd87aa9f37059cd24d4a1a9d37c627ce5f618a">
<meta property="og:image" content="https://ai-studio-static-online.cdn.bcebos.com/f4b33522eb5a45f0804b94a5c66b76a0a2d13345d6de499399580a031b6ccc74">
<meta property="og:image" content="https://ai-studio-static-online.cdn.bcebos.com/f21679e68d2b496698ed788a16d4ea2e5bc6f82b253a44ef9508b6a4fc9b6be4">
<meta property="og:image" content="https://ai-studio-static-online.cdn.bcebos.com/0487a67fe8704d959b7fd008e52b3942f9441f29d8e94481839ac5f209c538b3">
<meta property="og:image" content="https://ai-studio-static-online.cdn.bcebos.com/b7b9be40003947aa8bff8e72b84ee15033c7b3b1b61043eeb9b9c185aa83a210">
<meta property="og:image" content="https://ai-studio-static-online.cdn.bcebos.com/d59dd9da1c494016accd40c8f0a72a9908f06c5d2d9b42c4aaad815c14d4c8a1">
<meta property="og:image" content="https://ai-studio-static-online.cdn.bcebos.com/93e251bb309b4bb7a2031466ac62647089dbb280f2e84d5aaa468a9944f4654c">
<meta property="og:image" content="https://ai-studio-static-online.cdn.bcebos.com/7a3bcb1ca5cc4def9d93749bd963b402bc97568e22d24bd2855b6844db0c450b">
<meta property="og:image" content="https://ai-studio-static-online.cdn.bcebos.com/1ec38428c95d4ab4a133dd4262f130eddeee0befa6dd40f599b9ce562f442685">
<meta property="og:image" content="https://ai-studio-static-online.cdn.bcebos.com/d0bf0309b11944109b3b9d38280ffcf3e3921fe5a3714c3ebfbff64fc76f0dc7">
<meta property="og:image" content="https://ai-studio-static-online.cdn.bcebos.com/14ebf91897ea4d5787dfaaefe9e3030f0e6f704eec134440b4c495f74ab49003">
<meta property="og:image" content="https://github.com/shuziP/shuzip.github.io.git/2020/06/26/技术/PaddlePaddleYOLO-V3/output_129_0.png">
<meta property="og:image" content="https://github.com/shuziP/shuzip.github.io.git/2020/06/26/技术/PaddlePaddleYOLO-V3/output_131_0.png">
<meta property="og:image" content="https://github.com/shuziP/shuzip.github.io.git/2020/06/26/技术/PaddlePaddleYOLO-V3/output_142_0.png">
<meta property="og:updated_time" content="2020-03-07T17:18:47.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="目标检测PaddlePaddleYOLO-V3">
<meta name="twitter:description" content="对计算机而言，能够“看到”的是图像被编码之后的数字，但它很难解高层语义概念，比如图像或者视频帧中出现目标的是人还是物体，更无法定位目标出现在图像中哪个区域。目标检测的主要目的是让计算机可以自动识别图片或者视频帧中所有目标的类别，并在该目标周围绘制边界框，标示出每个目标的位置，如 图1 所示。">
<meta name="twitter:image" content="https://ai-studio-static-online.cdn.bcebos.com/e25116d994724f83abe3bef7f033c1c89bf34e083075494bb7833947c557f4fc">
  <link rel="canonical" href="https://github.com/shuziP/shuzip.github.io.git/2020/06/26/技术/PaddlePaddleYOLO-V3/">


<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>目标检测PaddlePaddleYOLO-V3 | shuzip</title>
  








  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">shuzip</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">blog</p>
      
  </div>

  <div class="site-nav-toggle">
    <button aria-label="Navigationsleiste an/ausschalten">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
    <ul id="menu" class="menu">
        
        
        
          
          <li class="menu-item menu-item-home">

    <a href="/HOME/" rel="section">HOME</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-代码code">

    <a href="/code/" rel="section">代码code</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-音乐music">

    <a href="/music/" rel="section">音乐music</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-数据分析analysis">

    <a href="/analysis/" rel="section">数据分析analysis</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-内容分类categories">

    <a href="/categories/" rel="section">内容分类categories</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-about">

    <a href="/about/" rel="section">ABOUT</a>

  </li>
    </ul>
    

</nav>

</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://github.com/shuziP/shuzip.github.io.git/2020/06/26/技术/PaddlePaddleYOLO-V3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="shuzip">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="shuzip">
    </span>
      <header class="post-header">

        
          <h1 class="post-title" itemprop="name headline">目标检测PaddlePaddleYOLO-V3

              
            
          </h1>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              

              
                
              

              <time title="Erstellt: 2020-06-26 00:40:05" itemprop="dateCreated datePublished" datetime="2020-06-26T00:40:05+08:00">2020-06-26</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Bearbeitet am</span>
                
                <time title="Geändert am: 2020-03-08 01:18:47" itemprop="dateModified" datetime="2020-03-08T01:18:47+08:00">2020-03-08</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">in</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/技术/" itemprop="url" rel="index"><span itemprop="name">技术</span></a></span>

                
                
              
            </span>
          

          <br>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>对计算机而言，能够“看到”的是图像被编码之后的数字，但它很难解高层语义概念，比如图像或者视频帧中出现目标的是人还是物体，更无法定位目标出现在图像中哪个区域。目标检测的主要目的是让计算机可以自动识别图片或者视频帧中所有目标的类别，并在该目标周围绘制边界框，标示出每个目标的位置，如 <strong>图1</strong> 所示。<br><br></br></p>
<center><img src="https://ai-studio-static-online.cdn.bcebos.com/e25116d994724f83abe3bef7f033c1c89bf34e083075494bb7833947c557f4fc" width = "700"  div align=center" width = "800"></center>
<center><br>图1：图像分类和目标检测示意图</br></center>
<br></br>

<ul>
<li>图1（a）是图像分类任务，只需识别出这是一张斑马的图片。 </li>
<li>图1（b）是目标检测任务，不仅要识别出这是一张斑马的图片，还要标出图中斑马的位置。</li>
</ul>
<h1 id="目标检测发展历程"><a href="#目标检测发展历程" class="headerlink" title="目标检测发展历程"></a>目标检测发展历程</h1><a id="more"></a>
<p>在上一节中我们学习了图像分类处理基本流程，先使用卷积神经网络提取图像特征，然后再用这些特征预测分类概率，根据训练样本标签建立起分类损失函数，开启端到端的训练，如 <strong>图2</strong> 所示。<br><br></br></p>
<center><img src="https://ai-studio-static-online.cdn.bcebos.com/d131c45973a244c590c3d1ee3866a694b134299542284b22b794e4ab76c4769d" width = "800"></center>
<center><br>图2：图像分类流程示意图</br></center>
<br></br>

<p>但对于目标检测问题，按照 <strong>图2</strong> 的流程则行不通。因为在图像分类任务中，对整张图提取特征的过程中没能体现出不同目标之间的区别，最终也就没法分别标示出每个物体所在的位置。</p>
<p>为了解决这个问题，结合图片分类任务取得的成功经验，我们可以将目标检测任务进行拆分。假设我们现在有某种方式可以在输入图片上生成一系列可能包含物体的区域，这些区域称为候选区域，在一张图上可以生成很多个候选区域。然后对每个候选区域，可以把它单独当成一幅图像来看待，使用图像分类模型对它进行分类，看它属于哪个类别或者背景（即不包含任何物体的类别）。</p>
<p>上一节我们学过如何解决图像分类任务，使用卷积神经网络对一幅图像进行分类不再是一件困难的事情。那么，现在问题的关键就是如何产生候选区域？比如我们可以使用穷举法来产生候选区域，如图3所示。<br><br></br></p>
<center><img src="https://ai-studio-static-online.cdn.bcebos.com/57755ac8e95a460f9262afc7c37a0db51f66027ff86c40e2967a2e22524c20a1" width = "800"></center>
<center><br>图3：候选区域</br></center>
<br></br>

<p>A为图像上的某个像素点，B为A右下方另外一个像素点，A、B两点可以确定一个矩形框，记作AB。</p>
<ul>
<li>如图3（a）所示：A在图片左上角位置，B遍历除A之外的所有位置，生成矩形框A1B1, …, A1Bn, …</li>
<li>如图3（b）所示：A在图片中间某个位置，B遍历A右下方所有位置，生成矩形框AkB1, …, AkBn, …</li>
</ul>
<p>当A遍历图像上所有像素点，B则遍历它右下方所有的像素点，最终生成的矩形框集合{AiBj}将会包含图像上所有可以选择的区域。</p>
<p>只要我们对每个候选区域的分类足够的准确，则一定能找到跟实际物体足够接近的区域来。穷举法也许能得到正确的预测结果，但其计算量也是非常巨大的，其所生成的总的候选区域数目约为$\frac{W^2 H^2}{4}$，假设$H=W=100$，总数将会达到$2.5 \times 10^{7}$个，如此多的候选区域使得这种方法几乎没有什么实用性。但是通过这种方式，我们可以看出，假设分类任务完成的足够完美，从理论上来讲检测任务也是可以解决的，亟待解决的问题是如何设计出合适的方法来产生候选区域。</p>
<p>科学家们开始思考，是否可以应用传统图像算法先产生候选区域，然后再用卷积神经网络对这些区域进行分类？</p>
<ul>
<li>2013年，<a href="https://arxiv.org/abs/1311.2524">Ross Girshick</a> 等人于首次将CNN的方法应用在目标检测任务上，他们使用传统图像算法<a href="https://link.springer.com/article/10.1007/s11263-013-0620-5">selective search</a>产生候选区域，取得了极大的成功，这就是对目标检测领域影响深远的区域卷积神经网络(R-CNN)模型。</li>
<li>2015年，<a href="https://arxiv.org/abs/1504.08083">Ross Girshick</a> 对此方法进行了改进，提出了Fast RCNN模型。通过将不同区域的物体共用卷积层的计算，大大缩减了计算量，提高了处理速度，而且还引入了调整目标物体位置的回归方法，进一步提高了位置预测的准确性。</li>
<li>2015年，<a href="https://arxiv.org/abs/1506.01497">Shaoqing Ren</a> 等人提出了Faster RCNN模型，提出了RPN的方法来产生物体的候选区域，这一方法里面不再需要使用传统的图像处理算法来产生候选区域，进一步提升了处理速度。</li>
<li>2017年，<a href="https://arxiv.org/abs/1703.06870">Kaiming He</a> 等人于提出了Mask RCNN模型，只需要在Faster RCNN模型上添加比较少的计算量，就可以同时实现目标检测和物体实例分割两个任务。</li>
</ul>
<p>以上都是基于R-CNN系列的著名模型，对目标检测方向的发展有着较大的影响力。此外，还有一些其他模型，比如<a href="https://arxiv.org/abs/1512.02325">SSD</a>、YOLO(<a href="https://arxiv.org/abs/1506.02640v5">1</a>, <a href="https://arxiv.org/abs/1612.08242">2</a>, <a href="https://arxiv.org/abs/1804.02767">3</a>)、<a href="https://arxiv.org/abs/1605.06409">R-FCN</a>等也都是目标检测领域流行的模型结构。</p>
<p>R-CNN的系列算法分成两个阶段，先在图像上产生候选区域，再对候选区域进行分类并预测目标物体位置，它们通常被叫做两阶段检测算法。SSD和YOLO算法则只使用一个网络同时产生候选区域并预测出物体的类别和位置，所以它们通常被叫做单阶段检测算法。由于篇幅所限，本章将重点介绍YOLO-V3算法，并用其完成林业病虫害数据集中的昆虫检测任务，主要涵盖如下内容：</p>
<ul>
<li>图像检测基础概念：介绍与目标检测任相关的基本概念，包括边界框、锚框和交并比等。</li>
<li>林业病虫害数据集：介绍数据集结构及数据预处理方法。</li>
<li>YOLO-V3目标检测模型：介绍算法原理，及如何应用林业病虫害数据集进行模型训练和测试。</li>
</ul>
<h2 id="目标检测基础概念"><a href="#目标检测基础概念" class="headerlink" title="目标检测基础概念"></a>目标检测基础概念</h2><p>在介绍目标检测算法之前，先介绍一些跟检测相关的基本概念，包括边界框、锚框和交并比等。</p>
<h3 id="边界框（bounding-box）"><a href="#边界框（bounding-box）" class="headerlink" title="边界框（bounding box）"></a>边界框（bounding box）</h3><p>检测任务需要同时预测物体的类别和位置，因此需要引入一些跟位置相关的概念。通常使用边界框（bounding box，bbox）来表示物体的位置，边界框是正好能包含住物体的矩形框，如 <strong>图4</strong> 所示，图中3个人分别对应3个边界框。<br><br></br></p>
<center><img src="https://ai-studio-static-online.cdn.bcebos.com/f581e1bfd07a414596368c9c03a1b30ea115a2e30a014be68b2c26961f5c38fa" width = "400"  div align=center"></center>
<center><br>图4：边界框</br></center>
<br></br>

<p>通常有两种格式来表示边界框的位置：</p>
<ol>
<li>xyxy，即$(x_1, y_1, x_2, y_2)$，其中$(x_1, y_1)$是矩形框左上角的坐标，$(x_2, y_2)$是矩形框右下角的坐标。图4中3个红色矩形框用xyxy格式表示如下：</li>
</ol>
<ul>
<li>左：$(40.93, 141.1, 226.99, 515.73)$。</li>
<li>中：$(214.29, 325.03, 399.82, 631.37)$。</li>
<li>右：$(247.2, 131.62, 480.0, 639.32)$。</li>
</ul>
<ol start="2">
<li>xywh，即$(x, y, w, h)$，其中$(x, y)$是矩形框中心点的坐标，w是矩形框的宽度，h是矩形框的高度。</li>
</ol>
<p>在检测任务中，训练数据集的标签里会给出目标物体真实边界框所对应的$(x_1, y_1, x_2, y_2)$，这样的边界框也被称为真实框（ground truth box），如 <strong>图4</strong> 所示，图中画出了3个人像所对应的真实框。模型会对目标物体可能出现的位置进行预测，由模型预测出的边界框则称为预测框（prediction box）。</p>
<hr>
<p><strong>注意：</strong></p>
<ol>
<li>在阅读代码时，请注意使用的是哪一种格式的表示方式。</li>
<li>图片坐标的原点在左上角，x轴向右为正方向，y轴向下为正方向。</li>
</ol>
<hr>
<p>要完成一项检测任务，我们通常希望模型能够根据输入的图片，输出一些预测的边界框，以及边界框中所包含的物体的类别或者说属于某个类别的概率，例如这种格式: $[L, P, x_1, y_1, x_2, y_2]$，其中L是类别标签，P是物体属于该类别的概率。一张输入图片可能会产生多个预测框，接下来让我们一起学习如何完成这样一项任务。</p>
<h3 id="锚框（Anchor）"><a href="#锚框（Anchor）" class="headerlink" title="锚框（Anchor）"></a>锚框（Anchor）</h3><p>锚框与物体边界框不同，是由人们假想出来的一种框。先设定好锚框的大小和形状，再以图像上某一个点为中心画出矩形框。在下图中，以像素点[300, 500]为中心可以使用下面的程序生成3个框，如图中蓝色框所示，其中锚框A1跟人像区域非常接近。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 画图展示如何绘制边界框和锚框</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> matplotlib.patches <span class="keyword">as</span> patches</span><br><span class="line"><span class="keyword">from</span> matplotlib.image <span class="keyword">import</span> imread</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义画矩形框的程序    </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">draw_rectangle</span><span class="params">(currentAxis, bbox, edgecolor = <span class="string">'k'</span>, facecolor = <span class="string">'y'</span>, fill=False, linestyle=<span class="string">'-'</span>)</span>:</span></span><br><span class="line">    <span class="comment"># currentAxis，坐标轴，通过plt.gca()获取</span></span><br><span class="line">    <span class="comment"># bbox，边界框，包含四个数值的list， [x1, y1, x2, y2]</span></span><br><span class="line">    <span class="comment"># edgecolor，边框线条颜色</span></span><br><span class="line">    <span class="comment"># facecolor，填充颜色</span></span><br><span class="line">    <span class="comment"># fill, 是否填充</span></span><br><span class="line">    <span class="comment"># linestype，边框线型</span></span><br><span class="line">    <span class="comment"># patches.Rectangle需要传入左上角坐标、矩形区域的宽度、高度等参数</span></span><br><span class="line">    rect=patches.Rectangle((bbox[<span class="number">0</span>], bbox[<span class="number">1</span>]), bbox[<span class="number">2</span>]-bbox[<span class="number">0</span>]+<span class="number">1</span>, bbox[<span class="number">3</span>]-bbox[<span class="number">1</span>]+<span class="number">1</span>, linewidth=<span class="number">1</span>,</span><br><span class="line">                           edgecolor=edgecolor,facecolor=facecolor,fill=fill, linestyle=linestyle)</span><br><span class="line">    currentAxis.add_patch(rect)</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">plt.figure(figsize=(<span class="number">10</span>, <span class="number">10</span>))</span><br><span class="line"></span><br><span class="line">filename = <span class="string">'/home/aistudio/work/images/section3/000000086956.jpg'</span></span><br><span class="line">im = imread(filename)</span><br><span class="line">plt.imshow(im)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用xyxy格式表示物体真实框</span></span><br><span class="line">bbox1 = [<span class="number">214.29</span>, <span class="number">325.03</span>, <span class="number">399.82</span>, <span class="number">631.37</span>]</span><br><span class="line">bbox2 = [<span class="number">40.93</span>, <span class="number">141.1</span>, <span class="number">226.99</span>, <span class="number">515.73</span>]</span><br><span class="line">bbox3 = [<span class="number">247.2</span>, <span class="number">131.62</span>, <span class="number">480.0</span>, <span class="number">639.32</span>]</span><br><span class="line"></span><br><span class="line">currentAxis=plt.gca()</span><br><span class="line"></span><br><span class="line">draw_rectangle(currentAxis, bbox1, edgecolor=<span class="string">'r'</span>)</span><br><span class="line">draw_rectangle(currentAxis, bbox2, edgecolor=<span class="string">'r'</span>)</span><br><span class="line">draw_rectangle(currentAxis, bbox3,edgecolor=<span class="string">'r'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制锚框</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">draw_anchor_box</span><span class="params">(center, length, scales, ratios, img_height, img_width)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    以center为中心，产生一系列锚框</span></span><br><span class="line"><span class="string">    其中length指定了一个基准的长度</span></span><br><span class="line"><span class="string">    scales是包含多种尺寸比例的list</span></span><br><span class="line"><span class="string">    ratios是包含多种长宽比的list</span></span><br><span class="line"><span class="string">    img_height和img_width是图片的尺寸，生成的锚框范围不能超出图片尺寸之外</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    bboxes = []</span><br><span class="line">    <span class="keyword">for</span> scale <span class="keyword">in</span> scales:</span><br><span class="line">        <span class="keyword">for</span> ratio <span class="keyword">in</span> ratios:</span><br><span class="line">            h = length*scale*math.sqrt(ratio)</span><br><span class="line">            w = length*scale/math.sqrt(ratio) </span><br><span class="line">            x1 = max(center[<span class="number">0</span>] - w/<span class="number">2.</span>, <span class="number">0.</span>)</span><br><span class="line">            y1 = max(center[<span class="number">1</span>] - h/<span class="number">2.</span>, <span class="number">0.</span>)</span><br><span class="line">            x2 = min(center[<span class="number">0</span>] + w/<span class="number">2.</span> - <span class="number">1.0</span>, img_width - <span class="number">1.0</span>)</span><br><span class="line">            y2 = min(center[<span class="number">1</span>] + h/<span class="number">2.</span> - <span class="number">1.0</span>, img_height - <span class="number">1.0</span>)</span><br><span class="line">            print(center[<span class="number">0</span>], center[<span class="number">1</span>], w, h)</span><br><span class="line">            bboxes.append([x1, y1, x2, y2])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> bbox <span class="keyword">in</span> bboxes:</span><br><span class="line">        draw_rectangle(currentAxis, bbox, edgecolor = <span class="string">'b'</span>)</span><br><span class="line"></span><br><span class="line">img_height = im.shape[<span class="number">0</span>]</span><br><span class="line">img_width = im.shape[<span class="number">1</span>]        </span><br><span class="line">draw_anchor_box([<span class="number">300.</span>, <span class="number">500.</span>], <span class="number">100.</span>, [<span class="number">2.0</span>], [<span class="number">0.5</span>, <span class="number">1.0</span>, <span class="number">2.0</span>], img_height, img_width)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">################# 以下为添加文字说明和箭头###############################</span></span><br><span class="line"></span><br><span class="line">plt.text(<span class="number">285</span>, <span class="number">285</span>, <span class="string">'G1'</span>, color=<span class="string">'red'</span>, fontsize=<span class="number">20</span>)</span><br><span class="line">plt.arrow(<span class="number">300</span>, <span class="number">288</span>, <span class="number">30</span>, <span class="number">40</span>, color=<span class="string">'red'</span>, width=<span class="number">0.001</span>, length_includes_head=<span class="literal">True</span>, \</span><br><span class="line">         head_width=<span class="number">5</span>, head_length=<span class="number">10</span>, shape=<span class="string">'full'</span>)</span><br><span class="line"></span><br><span class="line">plt.text(<span class="number">190</span>, <span class="number">320</span>, <span class="string">'A1'</span>, color=<span class="string">'blue'</span>, fontsize=<span class="number">20</span>)</span><br><span class="line">plt.arrow(<span class="number">200</span>, <span class="number">320</span>, <span class="number">30</span>, <span class="number">40</span>, color=<span class="string">'blue'</span>, width=<span class="number">0.001</span>, length_includes_head=<span class="literal">True</span>, \</span><br><span class="line">         head_width=<span class="number">5</span>, head_length=<span class="number">10</span>, shape=<span class="string">'full'</span>)</span><br><span class="line"></span><br><span class="line">plt.text(<span class="number">160</span>, <span class="number">370</span>, <span class="string">'A2'</span>, color=<span class="string">'blue'</span>, fontsize=<span class="number">20</span>)</span><br><span class="line">plt.arrow(<span class="number">170</span>, <span class="number">370</span>, <span class="number">30</span>, <span class="number">40</span>, color=<span class="string">'blue'</span>, width=<span class="number">0.001</span>, length_includes_head=<span class="literal">True</span>, \</span><br><span class="line">         head_width=<span class="number">5</span>, head_length=<span class="number">10</span>, shape=<span class="string">'full'</span>)</span><br><span class="line"></span><br><span class="line">plt.text(<span class="number">115</span>, <span class="number">420</span>, <span class="string">'A3'</span>, color=<span class="string">'blue'</span>, fontsize=<span class="number">20</span>)</span><br><span class="line">plt.arrow(<span class="number">127</span>, <span class="number">420</span>, <span class="number">30</span>, <span class="number">40</span>, color=<span class="string">'blue'</span>, width=<span class="number">0.001</span>, length_includes_head=<span class="literal">True</span>, \</span><br><span class="line">         head_width=<span class="number">5</span>, head_length=<span class="number">10</span>, shape=<span class="string">'full'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#draw_anchor_box([200., 200.], 100., [2.0], [0.5, 1.0, 2.0])    </span></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<pre><code>(300.0, 500.0, 282.84271247461896, 141.4213562373095)
(300.0, 500.0, 200.0, 200.0)
(300.0, 500.0, 141.42135623730948, 282.842712474619)</code></pre><p><img src="output_4_1.png" alt="png"></p>
<p>在目标检测模型中，通常会以某种规则在图片上生成一系列锚框，将这些锚框当成可能的候选区域。模型对这些候选区域是否包含物体进行预测，如果包含目标物体，则还需要进一步预测出物体所属的类别。还有更为重要的一点是，由于锚框位置是固定的，它不大可能刚好跟物体边界框重合，所以需要在锚框的基础上进行微调以形成能准确描述物体位置的预测框，模型需要预测出微调的幅度。在训练过程中，模型通过学习不断的调整参数，最终能学会如何判别出锚框所代表的候选区域是否包含物体，如果包含物体的话，物体属于哪个类别，以及物体边界框相对于锚框位置需要调整的幅度。</p>
<p>不同的模型往往有着不同的生成锚框的方式，在后面的内容中，会详细介绍YOLO-V3算法里面产生锚框的规则，理解了它的设计方案，也很容易类推到其它模型上。</p>
<h3 id="交并比"><a href="#交并比" class="headerlink" title="交并比"></a>交并比</h3><p>上面我们画出了以点$(300, 500)$为中心，生成的三个锚框，我们可以看到锚框A1 与真实框 G1的重合度比较好。那么如何衡量这三个锚框跟真实框之间的关系呢，在检测任务中是使用交并比（Intersection of Union，IoU）作为衡量指标。这一概念来源于数学中的集合，用来描述两个集合$A$和$B$之间的关系，它等于两个集合的交集里面所包含的元素个数，除以它们的并集里面所包含的元素个数，具体计算公式如下：</p>
<p>$$IoU = \frac{A\cap B}{A \cup B}$$</p>
<p>我们将用这个概念来描述两个框之间的重合度。两个框可以看成是两个像素的集合，它们的交并比等于两个框重合部分的面积除以它们合并起来的面积。下图a中红色区域是两个框的重合面积，图b中蓝色区域是两个框的相并面积。用这两个面积相除即可得到它们之间的交并比，如 <strong>图5</strong> 所示。</p>
<p><br></br></p>
<center><img src="https://ai-studio-static-online.cdn.bcebos.com/1eaa96c6dd8149f59665d80384ba189eb9f4c9bcc5ef47a79027385cbac033a0" width = "300"></center>
<center><br>图5：交并比</br></center>
<br></br>


<p>假设两个矩形框A和B的位置分别为：<br>$$A:  [x_{a1}, y_{a1}, x_{a2}, y_{a2}]$$</p>
<p>$$B:  [x_{b1}, y_{b1}, x_{b2}, y_{b2}]$$</p>
<p>假如位置关系如 <strong>图6</strong> 所示：<br><br></br></p>
<center><img src="https://ai-studio-static-online.cdn.bcebos.com/50bbb215ee9d4c048fd8788e2828ec7694199c6eadf746dfb9a7b83c79c17a45" width = "300"></center>
<center><br>图6：计算交并比</br></center>
<br></br>

<p>如果二者有相交部分，则相交部分左上角坐标为：<br>$$x_1 = max(x_{a1}, x_{b1}), \ \ \ \ \ y_1 = max(y_{a1}, y_{b1})$$</p>
<p>相交部分右下角坐标为：<br>$$x_2 = min(x_{a2}, x_{b2}), \ \ \ \ \ y_2 = min(y_{a2}, y_{b2})$$</p>
<p>计算先交部分面积：<br>$$intersection = max(x_2 - x_1 + 1.0, 0) \cdot max(y_2 - y_1 + 1.0, 0)$$</p>
<p>矩形框A和B的面积分别是：<br>$$S_A = (x_{a2} - x_{a1} + 1.0) \cdot (y_{a2} - y_{a1} + 1.0)$$</p>
<p>$$S_B = (x_{b2} - x_{b1} + 1.0) \cdot (y_{b2} - y_{b1} + 1.0)$$</p>
<p>计算相并部分面积：<br>$$union = S_A + S_B - intersection$$</p>
<p>计算交并比：</p>
<p>$$IoU = \frac{intersection}{union}$$</p>
<hr>
<p><strong>思考：</strong></p>
<p>两个矩形框之间的相对位置关系，除了上面的示意图之外，还有哪些可能，上面的公式能否覆盖所有的情形？</p>
<hr>
<p>并交比计算程序如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 计算IoU，矩形框的坐标形式为xyxy，这个函数会被保存在box_utils.py文件中</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">box_iou_xyxy</span><span class="params">(box1, box2)</span>:</span></span><br><span class="line">    <span class="comment"># 获取box1左上角和右下角的坐标</span></span><br><span class="line">    x1min, y1min, x1max, y1max = box1[<span class="number">0</span>], box1[<span class="number">1</span>], box1[<span class="number">2</span>], box1[<span class="number">3</span>]</span><br><span class="line">    <span class="comment"># 计算box1的面积</span></span><br><span class="line">    s1 = (y1max - y1min + <span class="number">1.</span>) * (x1max - x1min + <span class="number">1.</span>)</span><br><span class="line">    <span class="comment"># 获取box2左上角和右下角的坐标</span></span><br><span class="line">    x2min, y2min, x2max, y2max = box2[<span class="number">0</span>], box2[<span class="number">1</span>], box2[<span class="number">2</span>], box2[<span class="number">3</span>]</span><br><span class="line">    <span class="comment"># 计算box2的面积</span></span><br><span class="line">    s2 = (y2max - y2min + <span class="number">1.</span>) * (x2max - x2min + <span class="number">1.</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 计算相交矩形框的坐标</span></span><br><span class="line">    xmin = np.maximum(x1min, x2min)</span><br><span class="line">    ymin = np.maximum(y1min, y2min)</span><br><span class="line">    xmax = np.minimum(x1max, x2max)</span><br><span class="line">    ymax = np.minimum(y1max, y2max)</span><br><span class="line">    <span class="comment"># 计算相交矩形行的高度、宽度、面积</span></span><br><span class="line">    inter_h = np.maximum(ymax - ymin + <span class="number">1.</span>, <span class="number">0.</span>)</span><br><span class="line">    inter_w = np.maximum(xmax - xmin + <span class="number">1.</span>, <span class="number">0.</span>)</span><br><span class="line">    intersection = inter_h * inter_w</span><br><span class="line">    <span class="comment"># 计算相并面积</span></span><br><span class="line">    union = s1 + s2 - intersection</span><br><span class="line">    <span class="comment"># 计算交并比</span></span><br><span class="line">    iou = intersection / union</span><br><span class="line">    <span class="keyword">return</span> iou</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">bbox1 = [<span class="number">100.</span>, <span class="number">100.</span>, <span class="number">200.</span>, <span class="number">200.</span>]</span><br><span class="line">bbox2 = [<span class="number">120.</span>, <span class="number">120.</span>, <span class="number">220.</span>, <span class="number">220.</span>]</span><br><span class="line">iou = box_iou_xyxy(bbox1, bbox2)</span><br><span class="line">print(<span class="string">'IoU is &#123;&#125;'</span>.format(iou))</span><br></pre></td></tr></table></figure>

<pre><code>IoU is 0.474026443176</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 计算IoU，矩形框的坐标形式为xywh</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">box_iou_xywh</span><span class="params">(box1, box2)</span>:</span></span><br><span class="line">    x1min, y1min = box1[<span class="number">0</span>] - box1[<span class="number">2</span>]/<span class="number">2.0</span>, box1[<span class="number">1</span>] - box1[<span class="number">3</span>]/<span class="number">2.0</span></span><br><span class="line">    x1max, y1max = box1[<span class="number">0</span>] + box1[<span class="number">2</span>]/<span class="number">2.0</span>, box1[<span class="number">1</span>] + box1[<span class="number">3</span>]/<span class="number">2.0</span></span><br><span class="line">    s1 = box1[<span class="number">2</span>] * box1[<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line">    x2min, y2min = box2[<span class="number">0</span>] - box2[<span class="number">2</span>]/<span class="number">2.0</span>, box2[<span class="number">1</span>] - box2[<span class="number">3</span>]/<span class="number">2.0</span></span><br><span class="line">    x2max, y2max = box2[<span class="number">0</span>] + box2[<span class="number">2</span>]/<span class="number">2.0</span>, box2[<span class="number">1</span>] + box2[<span class="number">3</span>]/<span class="number">2.0</span></span><br><span class="line">    s2 = box2[<span class="number">2</span>] * box2[<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line">    xmin = np.maximum(x1min, x2min)</span><br><span class="line">    ymin = np.maximum(y1min, y2min)</span><br><span class="line">    xmax = np.minimum(x1max, x2max)</span><br><span class="line">    ymax = np.minimum(y1max, y2max)</span><br><span class="line">    inter_h = np.maximum(ymax - ymin, <span class="number">0.</span>)</span><br><span class="line">    inter_w = np.maximum(xmax - xmin, <span class="number">0.</span>)</span><br><span class="line">    intersection = inter_h * inter_w</span><br><span class="line"></span><br><span class="line">    union = s1 + s2 - intersection</span><br><span class="line">    iou = intersection / union</span><br><span class="line">    <span class="keyword">return</span> iou</span><br></pre></td></tr></table></figure>

<p>为了直观的展示交并比的大小跟重合程度之间的关系，<strong>图7</strong> 示意了不同交并比下两个框之间的相对位置关系，从 IoU = 0.95 到 IoU = 0.<br><br></br></p>
<center><img src="https://ai-studio-static-online.cdn.bcebos.com/4befa4f120ca48a1a41986bf5542abb8ec136a1545214264bbf78e315cfb03f9" width = "500"></center>
<center><br>图7：不同交并比下两个框之间相对位置示意图</br></center>
<br></br>

<hr>
<p><strong>问题：</strong></p>
<ol>
<li>什么情况下两个矩形框的IoU等于1？</li>
<li>什么情况下两个矩形框的IoU等于0？</li>
</ol>
<hr>
<h1 id="林业病虫害数据集和数据预处理方法介绍"><a href="#林业病虫害数据集和数据预处理方法介绍" class="headerlink" title="林业病虫害数据集和数据预处理方法介绍"></a>林业病虫害数据集和数据预处理方法介绍</h1><p>在本次的课程中，将使用百度与林业大学合作开发的林业病虫害防治项目中用到昆虫数据集，关于该项目和数据集的更多信息，可以参考<a href="补充报道文章链接">相关报道</a>。在这一小节中将为读者介绍该数据集，以及计算机视觉任务中常用的数据预处理方法。</p>
<h2 id="读取AI识虫数据集标注信息"><a href="#读取AI识虫数据集标注信息" class="headerlink" title="读取AI识虫数据集标注信息"></a>读取AI识虫数据集标注信息</h2><p>AI识虫数据集结构如下：</p>
<ul>
<li>提供了2183张图片，其中训练集1693张，验证集245，测试集245张。</li>
<li>包含7种昆虫，分别是Boerner、Leconte、Linnaeus、acuminatus、armandi、coleoptera和linnaeus。</li>
<li>包含了图片和标注，请读者先将数据解压，并存放在insects目录下。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 解压数据脚本，第一次运行时打开注释，将文件解压到work目录下</span></span><br><span class="line"><span class="comment"># !unzip -d /home/aistudio/work /home/aistudio/data/data19638/insects.zip</span></span><br></pre></td></tr></table></figure>

<p>将数据解压之后，可以看到insects目录下的结构如下所示。</p>
<pre><code>insects
    |---train
    |         |---annotations
    |         |         |---xmls
    |         |                  |---100.xml
    |         |                  |---101.xml
    |         |                  |---...
    |         |
    |         |---images
    |                   |---100.jpeg
    |                   |---101.jpeg
    |                   |---...
    |
    |---val
    |        |---annotations
    |        |         |---xmls
    |        |                  |---1221.xml
    |        |                  |---1277.xml
    |        |                  |---...
    |        |
    |        |---images
    |                  |---1221.jpeg
    |                  |---1277.jpeg
    |                  |---...
    |
    |---test
             |---images
                       |---1833.jpeg
                       |---1838.jpeg
                       |---...</code></pre><p>insects包含train、val和test三个文件夹。train/annotations/xmls目录下存放着图片的标注。每个xml文件是对一张图片的说明，包括图片尺寸、包含的昆虫名称、在图片上出现的位置等信息。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">&lt;annotation&gt;</span><br><span class="line">        &lt;folder&gt;刘霏霏&lt;/folder&gt;</span><br><span class="line">        &lt;filename&gt;100.jpeg&lt;/filename&gt;</span><br><span class="line">        &lt;path&gt;/home/fion/桌面/刘霏霏/100.jpeg&lt;/path&gt;</span><br><span class="line">        &lt;source&gt;</span><br><span class="line">                &lt;database&gt;Unknown&lt;/database&gt;</span><br><span class="line">        &lt;/source&gt;</span><br><span class="line">        &lt;size&gt;</span><br><span class="line">                &lt;width&gt;1336&lt;/width&gt;</span><br><span class="line">                &lt;height&gt;1336&lt;/height&gt;</span><br><span class="line">                &lt;depth&gt;3&lt;/depth&gt;</span><br><span class="line">        &lt;/size&gt;</span><br><span class="line">        &lt;segmented&gt;0&lt;/segmented&gt;</span><br><span class="line">        &lt;object&gt;</span><br><span class="line">                &lt;name&gt;Boerner&lt;/name&gt;</span><br><span class="line">                &lt;pose&gt;Unspecified&lt;/pose&gt;</span><br><span class="line">                &lt;truncated&gt;0&lt;/truncated&gt;</span><br><span class="line">                &lt;difficult&gt;0&lt;/difficult&gt;</span><br><span class="line">                &lt;bndbox&gt;</span><br><span class="line">                        &lt;xmin&gt;500&lt;/xmin&gt;</span><br><span class="line">                        &lt;ymin&gt;893&lt;/ymin&gt;</span><br><span class="line">                        &lt;xmax&gt;656&lt;/xmax&gt;</span><br><span class="line">                        &lt;ymax&gt;966&lt;/ymax&gt;</span><br><span class="line">                &lt;/bndbox&gt;</span><br><span class="line">        &lt;/object&gt;</span><br><span class="line">        &lt;object&gt;</span><br><span class="line">                &lt;name&gt;Leconte&lt;/name&gt;</span><br><span class="line">                &lt;pose&gt;Unspecified&lt;/pose&gt;</span><br><span class="line">                &lt;truncated&gt;0&lt;/truncated&gt;</span><br><span class="line">                &lt;difficult&gt;0&lt;/difficult&gt;</span><br><span class="line">                &lt;bndbox&gt;</span><br><span class="line">                        &lt;xmin&gt;622&lt;/xmin&gt;</span><br><span class="line">                        &lt;ymin&gt;490&lt;/ymin&gt;</span><br><span class="line">                        &lt;xmax&gt;756&lt;/xmax&gt;</span><br><span class="line">                        &lt;ymax&gt;610&lt;/ymax&gt;</span><br><span class="line">                &lt;/bndbox&gt;</span><br><span class="line">        &lt;/object&gt;</span><br><span class="line">        &lt;object&gt;</span><br><span class="line">                &lt;name&gt;armandi&lt;/name&gt;</span><br><span class="line">                &lt;pose&gt;Unspecified&lt;/pose&gt;</span><br><span class="line">                &lt;truncated&gt;0&lt;/truncated&gt;</span><br><span class="line">                &lt;difficult&gt;0&lt;/difficult&gt;</span><br><span class="line">                &lt;bndbox&gt;</span><br><span class="line">                        &lt;xmin&gt;432&lt;/xmin&gt;</span><br><span class="line">                        &lt;ymin&gt;663&lt;/ymin&gt;</span><br><span class="line">                        &lt;xmax&gt;517&lt;/xmax&gt;</span><br><span class="line">                        &lt;ymax&gt;729&lt;/ymax&gt;</span><br><span class="line">                &lt;/bndbox&gt;</span><br><span class="line">        &lt;/object&gt;</span><br><span class="line">        &lt;object&gt;</span><br><span class="line">                &lt;name&gt;coleoptera&lt;/name&gt;</span><br><span class="line">                &lt;pose&gt;Unspecified&lt;/pose&gt;</span><br><span class="line">                &lt;truncated&gt;0&lt;/truncated&gt;</span><br><span class="line">                &lt;difficult&gt;0&lt;/difficult&gt;</span><br><span class="line">                &lt;bndbox&gt;</span><br><span class="line">                        &lt;xmin&gt;624&lt;/xmin&gt;</span><br><span class="line">                        &lt;ymin&gt;685&lt;/ymin&gt;</span><br><span class="line">                        &lt;xmax&gt;697&lt;/xmax&gt;</span><br><span class="line">                        &lt;ymax&gt;771&lt;/ymax&gt;</span><br><span class="line">                &lt;/bndbox&gt;</span><br><span class="line">        &lt;/object&gt;</span><br><span class="line">        &lt;object&gt;</span><br><span class="line">                &lt;name&gt;linnaeus&lt;/name&gt;</span><br><span class="line">                &lt;pose&gt;Unspecified&lt;/pose&gt;</span><br><span class="line">                &lt;truncated&gt;0&lt;/truncated&gt;</span><br><span class="line">                &lt;difficult&gt;0&lt;/difficult&gt;</span><br><span class="line">                &lt;bndbox&gt;</span><br><span class="line">                        &lt;xmin&gt;783&lt;/xmin&gt;</span><br><span class="line">                        &lt;ymin&gt;700&lt;/ymin&gt;</span><br><span class="line">                        &lt;xmax&gt;856&lt;/xmax&gt;</span><br><span class="line">                        &lt;ymax&gt;802&lt;/ymax&gt;</span><br><span class="line">                &lt;/bndbox&gt;</span><br><span class="line">        &lt;/object&gt;</span><br><span class="line">&lt;/annotation&gt;</span><br></pre></td></tr></table></figure>

<p>上面列出的xml文件中的主要参数说明如下：</p>
<p>-size：图片尺寸</p>
<p>-object：图片中包含的物体，一张图片可能中包含多个物体</p>
<ul>
<li>name：昆虫名称</li>
<li>bndbox：物体真实框</li>
<li>difficult：识别是否困难</li>
</ul>
<p>下面我们将从数据集中读取xml文件，将每张图片的标注信息读取出来。在读取具体的标注文件之前，我们先完成一件事情，就是将昆虫的类别名字（字符串）转化成数字表示的类别。因为神经网络里面计算时需要的输入类型是数值型的，所以需要将字符串表示的类别转化成具体的数字。昆虫类别名称的列表是：[‘Boerner’, ‘Leconte’, ‘Linnaeus’, ‘acuminatus’, ‘armandi’, ‘coleoptera’, ‘linnaeus’]，这里我们约定此列表中：’Boerner’对应类别0，’Leconte’对应类别1，…，’linnaeus’对应类别6。使用下面的程序可以得到表示名称字符串和数字类别之间映射关系的字典。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">INSECT_NAMES = [<span class="string">'Boerner'</span>, <span class="string">'Leconte'</span>, <span class="string">'Linnaeus'</span>, </span><br><span class="line">                <span class="string">'acuminatus'</span>, <span class="string">'armandi'</span>, <span class="string">'coleoptera'</span>, <span class="string">'linnaeus'</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_insect_names</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    return a dict, as following,</span></span><br><span class="line"><span class="string">        &#123;'Boerner': 0,</span></span><br><span class="line"><span class="string">         'Leconte': 1,</span></span><br><span class="line"><span class="string">         'Linnaeus': 2, </span></span><br><span class="line"><span class="string">         'acuminatus': 3,</span></span><br><span class="line"><span class="string">         'armandi': 4,</span></span><br><span class="line"><span class="string">         'coleoptera': 5,</span></span><br><span class="line"><span class="string">         'linnaeus': 6</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">    It can map the insect name into an integer label.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    insect_category2id = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> i, item <span class="keyword">in</span> enumerate(INSECT_NAMES):</span><br><span class="line">        insect_category2id[item] = i</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> insect_category2id</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cname2cid = get_insect_names()</span><br><span class="line">cname2cid</span><br></pre></td></tr></table></figure>

<pre><code>{&apos;Boerner&apos;: 0,
 &apos;Leconte&apos;: 1,
 &apos;Linnaeus&apos;: 2,
 &apos;acuminatus&apos;: 3,
 &apos;armandi&apos;: 4,
 &apos;coleoptera&apos;: 5,
 &apos;linnaeus&apos;: 6}</code></pre><p>调用get_insect_names函数返回一个dict，其键-值对描述了昆虫名称-数字类别之间的映射关系。</p>
<p>下面的程序从annotations/xml目录下面读取所有文件标注信息。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> xml.etree.ElementTree <span class="keyword">as</span> ET</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_annotations</span><span class="params">(cname2cid, datadir)</span>:</span></span><br><span class="line">    filenames = os.listdir(os.path.join(datadir, <span class="string">'annotations'</span>, <span class="string">'xmls'</span>))</span><br><span class="line">    records = []</span><br><span class="line">    ct = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> fname <span class="keyword">in</span> filenames:</span><br><span class="line">        fid = fname.split(<span class="string">'.'</span>)[<span class="number">0</span>]</span><br><span class="line">        fpath = os.path.join(datadir, <span class="string">'annotations'</span>, <span class="string">'xmls'</span>, fname)</span><br><span class="line">        img_file = os.path.join(datadir, <span class="string">'images'</span>, fid + <span class="string">'.jpeg'</span>)</span><br><span class="line">        tree = ET.parse(fpath)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> tree.find(<span class="string">'id'</span>) <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            im_id = np.array([ct])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            im_id = np.array([int(tree.find(<span class="string">'id'</span>).text)])</span><br><span class="line"></span><br><span class="line">        objs = tree.findall(<span class="string">'object'</span>)</span><br><span class="line">        im_w = float(tree.find(<span class="string">'size'</span>).find(<span class="string">'width'</span>).text)</span><br><span class="line">        im_h = float(tree.find(<span class="string">'size'</span>).find(<span class="string">'height'</span>).text)</span><br><span class="line">        gt_bbox = np.zeros((len(objs), <span class="number">4</span>), dtype=np.float32)</span><br><span class="line">        gt_class = np.zeros((len(objs), ), dtype=np.int32)</span><br><span class="line">        is_crowd = np.zeros((len(objs), ), dtype=np.int32)</span><br><span class="line">        difficult = np.zeros((len(objs), ), dtype=np.int32)</span><br><span class="line">        <span class="keyword">for</span> i, obj <span class="keyword">in</span> enumerate(objs):</span><br><span class="line">            cname = obj.find(<span class="string">'name'</span>).text</span><br><span class="line">            gt_class[i] = cname2cid[cname]</span><br><span class="line">            _difficult = int(obj.find(<span class="string">'difficult'</span>).text)</span><br><span class="line">            x1 = float(obj.find(<span class="string">'bndbox'</span>).find(<span class="string">'xmin'</span>).text)</span><br><span class="line">            y1 = float(obj.find(<span class="string">'bndbox'</span>).find(<span class="string">'ymin'</span>).text)</span><br><span class="line">            x2 = float(obj.find(<span class="string">'bndbox'</span>).find(<span class="string">'xmax'</span>).text)</span><br><span class="line">            y2 = float(obj.find(<span class="string">'bndbox'</span>).find(<span class="string">'ymax'</span>).text)</span><br><span class="line">            x1 = max(<span class="number">0</span>, x1)</span><br><span class="line">            y1 = max(<span class="number">0</span>, y1)</span><br><span class="line">            x2 = min(im_w - <span class="number">1</span>, x2)</span><br><span class="line">            y2 = min(im_h - <span class="number">1</span>, y2)</span><br><span class="line">            <span class="comment"># 这里使用xywh格式来表示目标物体真实框</span></span><br><span class="line">            gt_bbox[i] = [(x1+x2)/<span class="number">2.0</span> , (y1+y2)/<span class="number">2.0</span>, x2-x1+<span class="number">1.</span>, y2-y1+<span class="number">1.</span>]</span><br><span class="line">            is_crowd[i] = <span class="number">0</span></span><br><span class="line">            difficult[i] = _difficult</span><br><span class="line"></span><br><span class="line">        voc_rec = &#123;</span><br><span class="line">            <span class="string">'im_file'</span>: img_file,</span><br><span class="line">            <span class="string">'im_id'</span>: im_id,</span><br><span class="line">            <span class="string">'h'</span>: im_h,</span><br><span class="line">            <span class="string">'w'</span>: im_w,</span><br><span class="line">            <span class="string">'is_crowd'</span>: is_crowd,</span><br><span class="line">            <span class="string">'gt_class'</span>: gt_class,</span><br><span class="line">            <span class="string">'gt_bbox'</span>: gt_bbox,</span><br><span class="line">            <span class="string">'gt_poly'</span>: [],</span><br><span class="line">            <span class="string">'difficult'</span>: difficult</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">if</span> len(objs) != <span class="number">0</span>:</span><br><span class="line">            records.append(voc_rec)</span><br><span class="line">        ct += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> records</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">TRAINDIR = <span class="string">'/home/aistudio/work/insects/train'</span></span><br><span class="line">TESTDIR = <span class="string">'/home/aistudio/work/insects/test'</span></span><br><span class="line">VALIDDIR = <span class="string">'/home/aistudio/work/insects/val'</span></span><br><span class="line">cname2cid = get_insect_names()</span><br><span class="line">records = get_annotations(cname2cid, TRAINDIR)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">len(records)</span><br></pre></td></tr></table></figure>

<pre><code>1693</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">records[<span class="number">0</span>]</span><br></pre></td></tr></table></figure>

<pre><code>{&apos;difficult&apos;: array([0, 0, 0, 0, 0], dtype=int32),
 &apos;gt_bbox&apos;: array([[600. , 344.5, 135. , 172. ],
        [540.5, 705. ,  56. , 129. ],
        [661. , 831. ,  81. ,  71. ],
        [782.5, 545.5,  48. ,  82. ],
        [823. , 678. ,  59. ,  75. ]], dtype=float32),
 &apos;gt_class&apos;: array([1, 0, 4, 2, 5], dtype=int32),
 &apos;gt_poly&apos;: [],
 &apos;h&apos;: 1224.0,
 &apos;im_file&apos;: &apos;/home/aistudio/work/insects/train/images/693.jpeg&apos;,
 &apos;im_id&apos;: array([0]),
 &apos;is_crowd&apos;: array([0, 0, 0, 0, 0], dtype=int32),
 &apos;w&apos;: 1224.0}</code></pre><p>通过上面的程序，将所有训练数据集的标注数据全部读取出来了，存放在records列表下面，其中每一个元素是一张图片的标注数据，包含了图片存放地址，图片id，图片高度和宽度，图片中所包含的目标物体的种类和位置。</p>
<h2 id="数据读取和预处理"><a href="#数据读取和预处理" class="headerlink" title="数据读取和预处理"></a>数据读取和预处理</h2><p>数据预处理是训练神经网络时非常重要的步骤。合适的预处理方法，可以帮助模型更好的收敛并防止过拟合。首先我们需要从磁盘读入数据，然后需要对这些数据进行预处理，为了保证网络运行的速度通常还要对数据预处理进行加速。</p>
<h3 id="数据读取"><a href="#数据读取" class="headerlink" title="数据读取"></a>数据读取</h3><p>前面已经将图片的所有描述信息保存在records中了，其中的每一个元素包含了一张图片的描述，下面的程序展示了如何根据records里面的描述读取图片及标注。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">### 数据读取</span></span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_bbox</span><span class="params">(gt_bbox, gt_class)</span>:</span></span><br><span class="line">    <span class="comment"># 对于一般的检测任务来说，一张图片上往往会有多个目标物体</span></span><br><span class="line">    <span class="comment"># 设置参数MAX_NUM = 50， 即一张图片最多取50个真实框；如果真实</span></span><br><span class="line">    <span class="comment"># 框的数目少于50个，则将不足部分的gt_bbox, gt_class和gt_score的各项数值全设置为0</span></span><br><span class="line">    MAX_NUM = <span class="number">50</span></span><br><span class="line">    gt_bbox2 = np.zeros((MAX_NUM, <span class="number">4</span>))</span><br><span class="line">    gt_class2 = np.zeros((MAX_NUM,))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(gt_bbox)):</span><br><span class="line">        gt_bbox2[i, :] = gt_bbox[i, :]</span><br><span class="line">        gt_class2[i] = gt_class[i]</span><br><span class="line">        <span class="keyword">if</span> i &gt;= MAX_NUM:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">return</span> gt_bbox2, gt_class2</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_img_data_from_file</span><span class="params">(record)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    record is a dict as following,</span></span><br><span class="line"><span class="string">      record = &#123;</span></span><br><span class="line"><span class="string">            'im_file': img_file,</span></span><br><span class="line"><span class="string">            'im_id': im_id,</span></span><br><span class="line"><span class="string">            'h': im_h,</span></span><br><span class="line"><span class="string">            'w': im_w,</span></span><br><span class="line"><span class="string">            'is_crowd': is_crowd,</span></span><br><span class="line"><span class="string">            'gt_class': gt_class,</span></span><br><span class="line"><span class="string">            'gt_bbox': gt_bbox,</span></span><br><span class="line"><span class="string">            'gt_poly': [],</span></span><br><span class="line"><span class="string">            'difficult': difficult</span></span><br><span class="line"><span class="string">            &#125;</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    im_file = record[<span class="string">'im_file'</span>]</span><br><span class="line">    h = record[<span class="string">'h'</span>]</span><br><span class="line">    w = record[<span class="string">'w'</span>]</span><br><span class="line">    is_crowd = record[<span class="string">'is_crowd'</span>]</span><br><span class="line">    gt_class = record[<span class="string">'gt_class'</span>]</span><br><span class="line">    gt_bbox = record[<span class="string">'gt_bbox'</span>]</span><br><span class="line">    difficult = record[<span class="string">'difficult'</span>]</span><br><span class="line"></span><br><span class="line">    img = cv2.imread(im_file)</span><br><span class="line">    img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># check if h and w in record equals that read from img</span></span><br><span class="line">    <span class="keyword">assert</span> img.shape[<span class="number">0</span>] == int(h), \</span><br><span class="line">             <span class="string">"image height of &#123;&#125; inconsistent in record(&#123;&#125;) and img file(&#123;&#125;)"</span>.format(</span><br><span class="line">               im_file, h, img.shape[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">assert</span> img.shape[<span class="number">1</span>] == int(w), \</span><br><span class="line">             <span class="string">"image width of &#123;&#125; inconsistent in record(&#123;&#125;) and img file(&#123;&#125;)"</span>.format(</span><br><span class="line">               im_file, w, img.shape[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">    gt_boxes, gt_labels = get_bbox(gt_bbox, gt_class)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># gt_bbox 用相对值</span></span><br><span class="line">    gt_boxes[:, <span class="number">0</span>] = gt_boxes[:, <span class="number">0</span>] / float(w)</span><br><span class="line">    gt_boxes[:, <span class="number">1</span>] = gt_boxes[:, <span class="number">1</span>] / float(h)</span><br><span class="line">    gt_boxes[:, <span class="number">2</span>] = gt_boxes[:, <span class="number">2</span>] / float(w)</span><br><span class="line">    gt_boxes[:, <span class="number">3</span>] = gt_boxes[:, <span class="number">3</span>] / float(h)</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> img, gt_boxes, gt_labels, (h, w)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">record = records[<span class="number">0</span>]</span><br><span class="line">img, gt_boxes, gt_labels, scales = get_img_data_from_file(record)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">img.shape</span><br></pre></td></tr></table></figure>

<pre><code>(1224, 1224, 3)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gt_boxes.shape</span><br></pre></td></tr></table></figure>

<pre><code>(50, 4)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gt_labels</span><br></pre></td></tr></table></figure>

<pre><code>array([1., 0., 4., 2., 5., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,
       0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,
       0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scales</span><br></pre></td></tr></table></figure>

<pre><code>(1224.0, 1224.0)</code></pre><p>get_img_data_from_file()函数可以返回图片数据的数据，它们是图像数据img, 真实框坐标gt_boxes, 真实框包含的物体类别gt_labels, 图像尺寸scales。</p>
<h3 id="数据预处理"><a href="#数据预处理" class="headerlink" title="数据预处理"></a>数据预处理</h3><p>在计算机视觉中，通常会对图像做一些随机的变化，产生相似但又不完全相同的样本。主要作用是扩大训练数据集，抑制过拟合，提升模型的泛化能力，常用的方法见下面的程序。</p>
<h4 id="随机改变亮暗、对比度和颜色等"><a href="#随机改变亮暗、对比度和颜色等" class="headerlink" title="随机改变亮暗、对比度和颜色等"></a><strong>随机改变亮暗、对比度和颜色等</strong></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image, ImageEnhance</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="comment"># 随机改变亮暗、对比度和颜色等</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">random_distort</span><span class="params">(img)</span>:</span></span><br><span class="line">    <span class="comment"># 随机改变亮度</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">random_brightness</span><span class="params">(img, lower=<span class="number">0.5</span>, upper=<span class="number">1.5</span>)</span>:</span></span><br><span class="line">        e = np.random.uniform(lower, upper)</span><br><span class="line">        <span class="keyword">return</span> ImageEnhance.Brightness(img).enhance(e)</span><br><span class="line">    <span class="comment"># 随机改变对比度</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">random_contrast</span><span class="params">(img, lower=<span class="number">0.5</span>, upper=<span class="number">1.5</span>)</span>:</span></span><br><span class="line">        e = np.random.uniform(lower, upper)</span><br><span class="line">        <span class="keyword">return</span> ImageEnhance.Contrast(img).enhance(e)</span><br><span class="line">    <span class="comment"># 随机改变颜色</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">random_color</span><span class="params">(img, lower=<span class="number">0.5</span>, upper=<span class="number">1.5</span>)</span>:</span></span><br><span class="line">        e = np.random.uniform(lower, upper)</span><br><span class="line">        <span class="keyword">return</span> ImageEnhance.Color(img).enhance(e)</span><br><span class="line"></span><br><span class="line">    ops = [random_brightness, random_contrast, random_color]</span><br><span class="line">    np.random.shuffle(ops)</span><br><span class="line"></span><br><span class="line">    img = Image.fromarray(img)</span><br><span class="line">    img = ops[<span class="number">0</span>](img)</span><br><span class="line">    img = ops[<span class="number">1</span>](img)</span><br><span class="line">    img = ops[<span class="number">2</span>](img)</span><br><span class="line">    img = np.asarray(img)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> img</span><br></pre></td></tr></table></figure>

<h4 id="随机填充"><a href="#随机填充" class="headerlink" title="随机填充"></a><strong>随机填充</strong></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 随机填充</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">random_expand</span><span class="params">(img,</span></span></span><br><span class="line"><span class="function"><span class="params">                  gtboxes,</span></span></span><br><span class="line"><span class="function"><span class="params">                  max_ratio=<span class="number">4.</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                  fill=None,</span></span></span><br><span class="line"><span class="function"><span class="params">                  keep_ratio=True,</span></span></span><br><span class="line"><span class="function"><span class="params">                  thresh=<span class="number">0.5</span>)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> random.random() &gt; thresh:</span><br><span class="line">        <span class="keyword">return</span> img, gtboxes</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> max_ratio &lt; <span class="number">1.0</span>:</span><br><span class="line">        <span class="keyword">return</span> img, gtboxes</span><br><span class="line"></span><br><span class="line">    h, w, c = img.shape</span><br><span class="line">    ratio_x = random.uniform(<span class="number">1</span>, max_ratio)</span><br><span class="line">    <span class="keyword">if</span> keep_ratio:</span><br><span class="line">        ratio_y = ratio_x</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        ratio_y = random.uniform(<span class="number">1</span>, max_ratio)</span><br><span class="line">    oh = int(h * ratio_y)</span><br><span class="line">    ow = int(w * ratio_x)</span><br><span class="line">    off_x = random.randint(<span class="number">0</span>, ow - w)</span><br><span class="line">    off_y = random.randint(<span class="number">0</span>, oh - h)</span><br><span class="line"></span><br><span class="line">    out_img = np.zeros((oh, ow, c))</span><br><span class="line">    <span class="keyword">if</span> fill <span class="keyword">and</span> len(fill) == c:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(c):</span><br><span class="line">            out_img[:, :, i] = fill[i] * <span class="number">255.0</span></span><br><span class="line"></span><br><span class="line">    out_img[off_y:off_y + h, off_x:off_x + w, :] = img</span><br><span class="line">    gtboxes[:, <span class="number">0</span>] = ((gtboxes[:, <span class="number">0</span>] * w) + off_x) / float(ow)</span><br><span class="line">    gtboxes[:, <span class="number">1</span>] = ((gtboxes[:, <span class="number">1</span>] * h) + off_y) / float(oh)</span><br><span class="line">    gtboxes[:, <span class="number">2</span>] = gtboxes[:, <span class="number">2</span>] / ratio_x</span><br><span class="line">    gtboxes[:, <span class="number">3</span>] = gtboxes[:, <span class="number">3</span>] / ratio_y</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> out_img.astype(<span class="string">'uint8'</span>), gtboxes</span><br></pre></td></tr></table></figure>

<h4 id="随机裁剪"><a href="#随机裁剪" class="headerlink" title="随机裁剪"></a><strong>随机裁剪</strong></h4><p>随机裁剪之前需要先定义两个函数，multi_box_iou_xywh和box_crop这两个函数将被保存在box_utils.py文件中。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">multi_box_iou_xywh</span><span class="params">(box1, box2)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    In this case, box1 or box2 can contain multi boxes.</span></span><br><span class="line"><span class="string">    Only two cases can be processed in this method:</span></span><br><span class="line"><span class="string">       1, box1 and box2 have the same shape, box1.shape == box2.shape</span></span><br><span class="line"><span class="string">       2, either box1 or box2 contains only one box, len(box1) == 1 or len(box2) == 1</span></span><br><span class="line"><span class="string">    If the shape of box1 and box2 does not match, and both of them contain multi boxes, it will be wrong.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">assert</span> box1.shape[<span class="number">-1</span>] == <span class="number">4</span>, <span class="string">"Box1 shape[-1] should be 4."</span></span><br><span class="line">    <span class="keyword">assert</span> box2.shape[<span class="number">-1</span>] == <span class="number">4</span>, <span class="string">"Box2 shape[-1] should be 4."</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    b1_x1, b1_x2 = box1[:, <span class="number">0</span>] - box1[:, <span class="number">2</span>] / <span class="number">2</span>, box1[:, <span class="number">0</span>] + box1[:, <span class="number">2</span>] / <span class="number">2</span></span><br><span class="line">    b1_y1, b1_y2 = box1[:, <span class="number">1</span>] - box1[:, <span class="number">3</span>] / <span class="number">2</span>, box1[:, <span class="number">1</span>] + box1[:, <span class="number">3</span>] / <span class="number">2</span></span><br><span class="line">    b2_x1, b2_x2 = box2[:, <span class="number">0</span>] - box2[:, <span class="number">2</span>] / <span class="number">2</span>, box2[:, <span class="number">0</span>] + box2[:, <span class="number">2</span>] / <span class="number">2</span></span><br><span class="line">    b2_y1, b2_y2 = box2[:, <span class="number">1</span>] - box2[:, <span class="number">3</span>] / <span class="number">2</span>, box2[:, <span class="number">1</span>] + box2[:, <span class="number">3</span>] / <span class="number">2</span></span><br><span class="line"></span><br><span class="line">    inter_x1 = np.maximum(b1_x1, b2_x1)</span><br><span class="line">    inter_x2 = np.minimum(b1_x2, b2_x2)</span><br><span class="line">    inter_y1 = np.maximum(b1_y1, b2_y1)</span><br><span class="line">    inter_y2 = np.minimum(b1_y2, b2_y2)</span><br><span class="line">    inter_w = inter_x2 - inter_x1</span><br><span class="line">    inter_h = inter_y2 - inter_y1</span><br><span class="line">    inter_w = np.clip(inter_w, a_min=<span class="number">0.</span>, a_max=<span class="literal">None</span>)</span><br><span class="line">    inter_h = np.clip(inter_h, a_min=<span class="number">0.</span>, a_max=<span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line">    inter_area = inter_w * inter_h</span><br><span class="line">    b1_area = (b1_x2 - b1_x1) * (b1_y2 - b1_y1)</span><br><span class="line">    b2_area = (b2_x2 - b2_x1) * (b2_y2 - b2_y1)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> inter_area / (b1_area + b2_area - inter_area)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">box_crop</span><span class="params">(boxes, labels, crop, img_shape)</span>:</span></span><br><span class="line">    x, y, w, h = map(float, crop)</span><br><span class="line">    im_w, im_h = map(float, img_shape)</span><br><span class="line"></span><br><span class="line">    boxes = boxes.copy()</span><br><span class="line">    boxes[:, <span class="number">0</span>], boxes[:, <span class="number">2</span>] = (boxes[:, <span class="number">0</span>] - boxes[:, <span class="number">2</span>] / <span class="number">2</span>) * im_w, (</span><br><span class="line">        boxes[:, <span class="number">0</span>] + boxes[:, <span class="number">2</span>] / <span class="number">2</span>) * im_w</span><br><span class="line">    boxes[:, <span class="number">1</span>], boxes[:, <span class="number">3</span>] = (boxes[:, <span class="number">1</span>] - boxes[:, <span class="number">3</span>] / <span class="number">2</span>) * im_h, (</span><br><span class="line">        boxes[:, <span class="number">1</span>] + boxes[:, <span class="number">3</span>] / <span class="number">2</span>) * im_h</span><br><span class="line"></span><br><span class="line">    crop_box = np.array([x, y, x + w, y + h])</span><br><span class="line">    centers = (boxes[:, :<span class="number">2</span>] + boxes[:, <span class="number">2</span>:]) / <span class="number">2.0</span></span><br><span class="line">    mask = np.logical_and(crop_box[:<span class="number">2</span>] &lt;= centers, centers &lt;= crop_box[<span class="number">2</span>:]).all(</span><br><span class="line">        axis=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    boxes[:, :<span class="number">2</span>] = np.maximum(boxes[:, :<span class="number">2</span>], crop_box[:<span class="number">2</span>])</span><br><span class="line">    boxes[:, <span class="number">2</span>:] = np.minimum(boxes[:, <span class="number">2</span>:], crop_box[<span class="number">2</span>:])</span><br><span class="line">    boxes[:, :<span class="number">2</span>] -= crop_box[:<span class="number">2</span>]</span><br><span class="line">    boxes[:, <span class="number">2</span>:] -= crop_box[:<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">    mask = np.logical_and(mask, (boxes[:, :<span class="number">2</span>] &lt; boxes[:, <span class="number">2</span>:]).all(axis=<span class="number">1</span>))</span><br><span class="line">    boxes = boxes * np.expand_dims(mask.astype(<span class="string">'float32'</span>), axis=<span class="number">1</span>)</span><br><span class="line">    labels = labels * mask.astype(<span class="string">'float32'</span>)</span><br><span class="line">    boxes[:, <span class="number">0</span>], boxes[:, <span class="number">2</span>] = (boxes[:, <span class="number">0</span>] + boxes[:, <span class="number">2</span>]) / <span class="number">2</span> / w, (</span><br><span class="line">        boxes[:, <span class="number">2</span>] - boxes[:, <span class="number">0</span>]) / w</span><br><span class="line">    boxes[:, <span class="number">1</span>], boxes[:, <span class="number">3</span>] = (boxes[:, <span class="number">1</span>] + boxes[:, <span class="number">3</span>]) / <span class="number">2</span> / h, (</span><br><span class="line">        boxes[:, <span class="number">3</span>] - boxes[:, <span class="number">1</span>]) / h</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> boxes, labels, mask.sum()</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 随机裁剪</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">random_crop</span><span class="params">(img,</span></span></span><br><span class="line"><span class="function"><span class="params">                boxes,</span></span></span><br><span class="line"><span class="function"><span class="params">                labels,</span></span></span><br><span class="line"><span class="function"><span class="params">                scales=[<span class="number">0.3</span>, <span class="number">1.0</span>],</span></span></span><br><span class="line"><span class="function"><span class="params">                max_ratio=<span class="number">2.0</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                constraints=None,</span></span></span><br><span class="line"><span class="function"><span class="params">                max_trial=<span class="number">50</span>)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> len(boxes) == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> img, boxes</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> constraints:</span><br><span class="line">        constraints = [(<span class="number">0.1</span>, <span class="number">1.0</span>), (<span class="number">0.3</span>, <span class="number">1.0</span>), (<span class="number">0.5</span>, <span class="number">1.0</span>), (<span class="number">0.7</span>, <span class="number">1.0</span>),</span><br><span class="line">                       (<span class="number">0.9</span>, <span class="number">1.0</span>), (<span class="number">0.0</span>, <span class="number">1.0</span>)]</span><br><span class="line"></span><br><span class="line">    img = Image.fromarray(img)</span><br><span class="line">    w, h = img.size</span><br><span class="line">    crops = [(<span class="number">0</span>, <span class="number">0</span>, w, h)]</span><br><span class="line">    <span class="keyword">for</span> min_iou, max_iou <span class="keyword">in</span> constraints:</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> range(max_trial):</span><br><span class="line">            scale = random.uniform(scales[<span class="number">0</span>], scales[<span class="number">1</span>])</span><br><span class="line">            aspect_ratio = random.uniform(max(<span class="number">1</span> / max_ratio, scale * scale), \</span><br><span class="line">                                          min(max_ratio, <span class="number">1</span> / scale / scale))</span><br><span class="line">            crop_h = int(h * scale / np.sqrt(aspect_ratio))</span><br><span class="line">            crop_w = int(w * scale * np.sqrt(aspect_ratio))</span><br><span class="line">            crop_x = random.randrange(w - crop_w)</span><br><span class="line">            crop_y = random.randrange(h - crop_h)</span><br><span class="line">            crop_box = np.array([[(crop_x + crop_w / <span class="number">2.0</span>) / w,</span><br><span class="line">                                  (crop_y + crop_h / <span class="number">2.0</span>) / h,</span><br><span class="line">                                  crop_w / float(w), crop_h / float(h)]])</span><br><span class="line"></span><br><span class="line">            iou = multi_box_iou_xywh(crop_box, boxes)</span><br><span class="line">            <span class="keyword">if</span> min_iou &lt;= iou.min() <span class="keyword">and</span> max_iou &gt;= iou.max():</span><br><span class="line">                crops.append((crop_x, crop_y, crop_w, crop_h))</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> crops:</span><br><span class="line">        crop = crops.pop(np.random.randint(<span class="number">0</span>, len(crops)))</span><br><span class="line">        crop_boxes, crop_labels, box_num = box_crop(boxes, labels, crop, (w, h))</span><br><span class="line">        <span class="keyword">if</span> box_num &lt; <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        img = img.crop((crop[<span class="number">0</span>], crop[<span class="number">1</span>], crop[<span class="number">0</span>] + crop[<span class="number">2</span>],</span><br><span class="line">                        crop[<span class="number">1</span>] + crop[<span class="number">3</span>])).resize(img.size, Image.LANCZOS)</span><br><span class="line">        img = np.asarray(img)</span><br><span class="line">        <span class="keyword">return</span> img, crop_boxes, crop_labels</span><br><span class="line">    img = np.asarray(img)</span><br><span class="line">    <span class="keyword">return</span> img, boxes, labels</span><br></pre></td></tr></table></figure>

<h4 id="随机缩放"><a href="#随机缩放" class="headerlink" title="随机缩放"></a><strong>随机缩放</strong></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 随机缩放</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">random_interp</span><span class="params">(img, size, interp=None)</span>:</span></span><br><span class="line">    interp_method = [</span><br><span class="line">        cv2.INTER_NEAREST,</span><br><span class="line">        cv2.INTER_LINEAR,</span><br><span class="line">        cv2.INTER_AREA,</span><br><span class="line">        cv2.INTER_CUBIC,</span><br><span class="line">        cv2.INTER_LANCZOS4,</span><br><span class="line">    ]</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> interp <span class="keyword">or</span> interp <span class="keyword">not</span> <span class="keyword">in</span> interp_method:</span><br><span class="line">        interp = interp_method[random.randint(<span class="number">0</span>, len(interp_method) - <span class="number">1</span>)]</span><br><span class="line">    h, w, _ = img.shape</span><br><span class="line">    im_scale_x = size / float(w)</span><br><span class="line">    im_scale_y = size / float(h)</span><br><span class="line">    img = cv2.resize(</span><br><span class="line">        img, <span class="literal">None</span>, <span class="literal">None</span>, fx=im_scale_x, fy=im_scale_y, interpolation=interp)</span><br><span class="line">    <span class="keyword">return</span> img</span><br></pre></td></tr></table></figure>

<h4 id="随机翻转"><a href="#随机翻转" class="headerlink" title="随机翻转"></a><strong>随机翻转</strong></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 随机翻转</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">random_flip</span><span class="params">(img, gtboxes, thresh=<span class="number">0.5</span>)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> random.random() &gt; thresh:</span><br><span class="line">        img = img[:, ::<span class="number">-1</span>, :]</span><br><span class="line">        gtboxes[:, <span class="number">0</span>] = <span class="number">1.0</span> - gtboxes[:, <span class="number">0</span>]</span><br><span class="line">    <span class="keyword">return</span> img, gtboxes</span><br></pre></td></tr></table></figure>

<h4 id="随机打乱真实框排列顺序"><a href="#随机打乱真实框排列顺序" class="headerlink" title="随机打乱真实框排列顺序"></a><strong>随机打乱真实框排列顺序</strong></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 随机打乱真实框排列顺序</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">shuffle_gtbox</span><span class="params">(gtbox, gtlabel)</span>:</span></span><br><span class="line">    gt = np.concatenate(</span><br><span class="line">        [gtbox, gtlabel[:, np.newaxis]], axis=<span class="number">1</span>)</span><br><span class="line">    idx = np.arange(gt.shape[<span class="number">0</span>])</span><br><span class="line">    np.random.shuffle(idx)</span><br><span class="line">    gt = gt[idx, :]</span><br><span class="line">    <span class="keyword">return</span> gt[:, :<span class="number">4</span>], gt[:, <span class="number">4</span>]</span><br></pre></td></tr></table></figure>

<h4 id="图像增广方法"><a href="#图像增广方法" class="headerlink" title="图像增广方法"></a><strong>图像增广方法</strong></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 图像增广方法汇总</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">image_augment</span><span class="params">(img, gtboxes, gtlabels, size, means=None)</span>:</span></span><br><span class="line">    <span class="comment"># 随机改变亮暗、对比度和颜色等</span></span><br><span class="line">    img = random_distort(img)</span><br><span class="line">    <span class="comment"># 随机填充</span></span><br><span class="line">    img, gtboxes = random_expand(img, gtboxes, fill=means)</span><br><span class="line">    <span class="comment"># 随机裁剪</span></span><br><span class="line">    img, gtboxes, gtlabels, = random_crop(img, gtboxes, gtlabels)</span><br><span class="line">    <span class="comment"># 随机缩放</span></span><br><span class="line">    img = random_interp(img, size)</span><br><span class="line">    <span class="comment"># 随机翻转</span></span><br><span class="line">    img, gtboxes = random_flip(img, gtboxes)</span><br><span class="line">    <span class="comment"># 随机打乱真实框排列顺序</span></span><br><span class="line">    gtboxes, gtlabels = shuffle_gtbox(gtboxes, gtlabels)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> img.astype(<span class="string">'float32'</span>), gtboxes.astype(<span class="string">'float32'</span>), gtlabels.astype(<span class="string">'int32'</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">img, gt_boxes, gt_labels, scales = get_img_data_from_file(record)</span><br><span class="line">size = <span class="number">512</span></span><br><span class="line">img, gt_boxes, gt_labels = image_augment(img, gt_boxes, gt_labels, size)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">img.shape</span><br></pre></td></tr></table></figure>

<pre><code>(512, 512, 3)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gt_boxes.shape</span><br></pre></td></tr></table></figure>

<pre><code>(50, 4)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gt_labels.shape</span><br></pre></td></tr></table></figure>

<pre><code>(50,)</code></pre><p>这里得到的img数据数值需要调整，需要除以255.，并且减去均值和方差，再将维度从[H, W, C]调整为[C, H, W]</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">img, gt_boxes, gt_labels, scales = get_img_data_from_file(record)</span><br><span class="line">size = <span class="number">512</span></span><br><span class="line">img, gt_boxes, gt_labels = image_augment(img, gt_boxes, gt_labels, size)</span><br><span class="line">mean = [<span class="number">0.485</span>, <span class="number">0.456</span>, <span class="number">0.406</span>]</span><br><span class="line">std = [<span class="number">0.229</span>, <span class="number">0.224</span>, <span class="number">0.225</span>]</span><br><span class="line">mean = np.array(mean).reshape((<span class="number">1</span>, <span class="number">1</span>, <span class="number">-1</span>))</span><br><span class="line">std = np.array(std).reshape((<span class="number">1</span>, <span class="number">1</span>, <span class="number">-1</span>))</span><br><span class="line">img = (img / <span class="number">255.0</span> - mean) / std</span><br><span class="line">img = img.astype(<span class="string">'float32'</span>).transpose((<span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">img</span><br></pre></td></tr></table></figure>

<p>将上面的过程整理成一个函数get_img_data</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_img_data</span><span class="params">(record, size=<span class="number">640</span>)</span>:</span></span><br><span class="line">    img, gt_boxes, gt_labels, scales = get_img_data_from_file(record)</span><br><span class="line">    img, gt_boxes, gt_labels = image_augment(img, gt_boxes, gt_labels, size)</span><br><span class="line">    mean = [<span class="number">0.485</span>, <span class="number">0.456</span>, <span class="number">0.406</span>]</span><br><span class="line">    std = [<span class="number">0.229</span>, <span class="number">0.224</span>, <span class="number">0.225</span>]</span><br><span class="line">    mean = np.array(mean).reshape((<span class="number">1</span>, <span class="number">1</span>, <span class="number">-1</span>))</span><br><span class="line">    std = np.array(std).reshape((<span class="number">1</span>, <span class="number">1</span>, <span class="number">-1</span>))</span><br><span class="line">    img = (img / <span class="number">255.0</span> - mean) / std</span><br><span class="line">    img = img.astype(<span class="string">'float32'</span>).transpose((<span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">    <span class="keyword">return</span> img, gt_boxes, gt_labels, scales</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">TRAINDIR = <span class="string">'/home/aistudio/work/insects/train'</span></span><br><span class="line">TESTDIR = <span class="string">'/home/aistudio/work/insects/test'</span></span><br><span class="line">VALIDDIR = <span class="string">'/home/aistudio/work/insects/val'</span></span><br><span class="line">cname2cid = get_insect_names()</span><br><span class="line">records = get_annotations(cname2cid, TRAINDIR)</span><br><span class="line"></span><br><span class="line">record = records[<span class="number">0</span>]</span><br><span class="line">img, gt_boxes, gt_labels, scales = get_img_data(record, size=<span class="number">480</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">img.shape</span><br></pre></td></tr></table></figure>

<pre><code>(3, 480, 480)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gt_boxes.shape</span><br></pre></td></tr></table></figure>

<pre><code>(50, 4)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gt_labels</span><br></pre></td></tr></table></figure>

<pre><code>array([0, 0, 0, 0, 1, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0,
       5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
       0, 0, 0, 0, 0, 0], dtype=int32)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scales</span><br></pre></td></tr></table></figure>

<pre><code>(1224.0, 1224.0)</code></pre><h3 id="批量数据读取与加速"><a href="#批量数据读取与加速" class="headerlink" title="批量数据读取与加速"></a>批量数据读取与加速</h3><p>上面的程序展示了如何读取一张图片的数据并加速，下面的代码实现了批量数据读取。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取一个批次内样本随机缩放的尺寸</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_img_size</span><span class="params">(mode)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> (mode == <span class="string">'train'</span>) <span class="keyword">or</span> (mode == <span class="string">'valid'</span>):</span><br><span class="line">        inds = np.array([<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>])</span><br><span class="line">        ii = np.random.choice(inds)</span><br><span class="line">        img_size = <span class="number">320</span> + ii * <span class="number">32</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        img_size = <span class="number">608</span></span><br><span class="line">    <span class="keyword">return</span> img_size</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将 list形式的batch数据 转化成多个array构成的tuple</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_array</span><span class="params">(batch_data)</span>:</span></span><br><span class="line">    img_array = np.array([item[<span class="number">0</span>] <span class="keyword">for</span> item <span class="keyword">in</span> batch_data], dtype = <span class="string">'float32'</span>)</span><br><span class="line">    gt_box_array = np.array([item[<span class="number">1</span>] <span class="keyword">for</span> item <span class="keyword">in</span> batch_data], dtype = <span class="string">'float32'</span>)</span><br><span class="line">    gt_labels_array = np.array([item[<span class="number">2</span>] <span class="keyword">for</span> item <span class="keyword">in</span> batch_data], dtype = <span class="string">'int32'</span>)</span><br><span class="line">    img_scale = np.array([item[<span class="number">3</span>] <span class="keyword">for</span> item <span class="keyword">in</span> batch_data], dtype=<span class="string">'int32'</span>)</span><br><span class="line">    <span class="keyword">return</span> img_array, gt_box_array, gt_labels_array, img_scale</span><br><span class="line"></span><br><span class="line"><span class="comment"># 批量读取数据，同一批次内图像的尺寸大小必须是一样的，</span></span><br><span class="line"><span class="comment"># 不同批次之间的大小是随机的，</span></span><br><span class="line"><span class="comment"># 由上面定义的get_img_size函数产生</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">data_loader</span><span class="params">(datadir, batch_size= <span class="number">10</span>, mode=<span class="string">'train'</span>)</span>:</span></span><br><span class="line">    cname2cid = get_insect_names()</span><br><span class="line">    records = get_annotations(cname2cid, datadir)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reader</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="keyword">if</span> mode == <span class="string">'train'</span>:</span><br><span class="line">            np.random.shuffle(records)</span><br><span class="line">        batch_data = []</span><br><span class="line">        img_size = get_img_size(mode)</span><br><span class="line">        <span class="keyword">for</span> record <span class="keyword">in</span> records:</span><br><span class="line">            <span class="comment">#print(record)</span></span><br><span class="line">            img, gt_bbox, gt_labels, im_shape = get_img_data(record, </span><br><span class="line">                                                             size=img_size)</span><br><span class="line">            batch_data.append((img, gt_bbox, gt_labels, im_shape))</span><br><span class="line">            <span class="keyword">if</span> len(batch_data) == batch_size:</span><br><span class="line">                <span class="keyword">yield</span> make_array(batch_data)</span><br><span class="line">                batch_data = []</span><br><span class="line">                img_size = get_img_size(mode)</span><br><span class="line">        <span class="keyword">if</span> len(batch_data) &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">yield</span> make_array(batch_data)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> reader</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">d = data_loader(<span class="string">'/home/aistudio/work/insects/train'</span>, batch_size=<span class="number">2</span>, mode=<span class="string">'train'</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">img, gt_boxes, gt_labels, im_shape = next(d())</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">img.shape, gt_boxes.shape, gt_labels.shape, im_shape.shape</span><br></pre></td></tr></table></figure>

<pre><code>((2, 3, 608, 608), (2, 50, 4), (2, 50), (2, 2))</code></pre><p>由于在数据预处理耗时较长，可能会成为网络训练速度的瓶颈，所以需要对预处理部分进行优化。通过使用Paddle提供的API <a href="https://www.paddlepaddle.org.cn/documentation/docs/zh/api_cn/io_cn/xmap_readers_cn.html#xmap-readers">paddle.reader.xmap_readers</a>可以开启多线程读取数据，具体实现代码如下。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> functools</span><br><span class="line"><span class="keyword">import</span> paddle</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用paddle.reader.xmap_readers实现多线程读取数据</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">multithread_loader</span><span class="params">(datadir, batch_size= <span class="number">10</span>, mode=<span class="string">'train'</span>)</span>:</span></span><br><span class="line">    cname2cid = get_insect_names()</span><br><span class="line">    records = get_annotations(cname2cid, datadir)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reader</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="keyword">if</span> mode == <span class="string">'train'</span>:</span><br><span class="line">            np.random.shuffle(records)</span><br><span class="line">        img_size = get_img_size(mode)</span><br><span class="line">        batch_data = []</span><br><span class="line">        <span class="keyword">for</span> record <span class="keyword">in</span> records:</span><br><span class="line">            batch_data.append((record, img_size))</span><br><span class="line">            <span class="keyword">if</span> len(batch_data) == batch_size:</span><br><span class="line">                <span class="keyword">yield</span> batch_data</span><br><span class="line">                batch_data = []</span><br><span class="line">                img_size = get_img_size(mode)</span><br><span class="line">        <span class="keyword">if</span> len(batch_data) &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">yield</span> batch_data</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_data</span><span class="params">(samples)</span>:</span></span><br><span class="line">        batch_data = []</span><br><span class="line">        <span class="keyword">for</span> sample <span class="keyword">in</span> samples:</span><br><span class="line">            record = sample[<span class="number">0</span>]</span><br><span class="line">            img_size = sample[<span class="number">1</span>]</span><br><span class="line">            img, gt_bbox, gt_labels, im_shape = get_img_data(record, size=img_size)</span><br><span class="line">            batch_data.append((img, gt_bbox, gt_labels, im_shape))</span><br><span class="line">        <span class="keyword">return</span> make_array(batch_data)</span><br><span class="line"></span><br><span class="line">    mapper = functools.partial(get_data, )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> paddle.reader.xmap_readers(mapper, reader, <span class="number">8</span>, <span class="number">10</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">d = multithread_loader(<span class="string">'/home/aistudio/work/insects/train'</span>, batch_size=<span class="number">2</span>, mode=<span class="string">'train'</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">img, gt_boxes, gt_labels, im_shape = next(d())</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">img.shape, gt_boxes.shape, gt_labels.shape, im_shape.shape</span><br></pre></td></tr></table></figure>

<pre><code>((2, 3, 480, 480), (2, 50, 4), (2, 50), (2, 2))</code></pre><p>至此，我们完成了如何查看数据集中的数据、提取数据标注信息、从文件读取图像和标注数据、数据增多、批量读取和加速等过程，通过multithread_loader可以返回img, gt_boxes, gt_labels, im_shape等数据，接下来就可以将它们输入神经网络应用在具体算法上面了。</p>
<p>在开始具体的算法讲解之前，先补充一下测试数据的读取代码，测试数据没有标注信息，也不需要做图像增广，代码如下所示。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 测试数据读取</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将 list形式的batch数据 转化成多个array构成的tuple</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_test_array</span><span class="params">(batch_data)</span>:</span></span><br><span class="line">    img_name_array = np.array([item[<span class="number">0</span>] <span class="keyword">for</span> item <span class="keyword">in</span> batch_data])</span><br><span class="line">    img_data_array = np.array([item[<span class="number">1</span>] <span class="keyword">for</span> item <span class="keyword">in</span> batch_data], dtype = <span class="string">'float32'</span>)</span><br><span class="line">    img_scale_array = np.array([item[<span class="number">2</span>] <span class="keyword">for</span> item <span class="keyword">in</span> batch_data], dtype=<span class="string">'int32'</span>)</span><br><span class="line">    <span class="keyword">return</span> img_name_array, img_data_array, img_scale_array</span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试数据读取</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_data_loader</span><span class="params">(datadir, batch_size= <span class="number">10</span>, test_image_size=<span class="number">608</span>, mode=<span class="string">'test'</span>)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    加载测试用的图片，测试数据没有groundtruth标签</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    image_names = os.listdir(datadir)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reader</span><span class="params">()</span>:</span></span><br><span class="line">        batch_data = []</span><br><span class="line">        img_size = test_image_size</span><br><span class="line">        <span class="keyword">for</span> image_name <span class="keyword">in</span> image_names:</span><br><span class="line">            file_path = os.path.join(datadir, image_name)</span><br><span class="line">            img = cv2.imread(file_path)</span><br><span class="line">            img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)</span><br><span class="line">            H = img.shape[<span class="number">0</span>]</span><br><span class="line">            W = img.shape[<span class="number">1</span>]</span><br><span class="line">            img = cv2.resize(img, (img_size, img_size))</span><br><span class="line"></span><br><span class="line">            mean = [<span class="number">0.485</span>, <span class="number">0.456</span>, <span class="number">0.406</span>]</span><br><span class="line">            std = [<span class="number">0.229</span>, <span class="number">0.224</span>, <span class="number">0.225</span>]</span><br><span class="line">            mean = np.array(mean).reshape((<span class="number">1</span>, <span class="number">1</span>, <span class="number">-1</span>))</span><br><span class="line">            std = np.array(std).reshape((<span class="number">1</span>, <span class="number">1</span>, <span class="number">-1</span>))</span><br><span class="line">            out_img = (img / <span class="number">255.0</span> - mean) / std</span><br><span class="line">            out_img = out_img.astype(<span class="string">'float32'</span>).transpose((<span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">            img = out_img <span class="comment">#np.transpose(out_img, (2,0,1))</span></span><br><span class="line">            im_shape = [H, W]</span><br><span class="line"></span><br><span class="line">            batch_data.append((image_name.split(<span class="string">'.'</span>)[<span class="number">0</span>], img, im_shape))</span><br><span class="line">            <span class="keyword">if</span> len(batch_data) == batch_size:</span><br><span class="line">                <span class="keyword">yield</span> make_test_array(batch_data)</span><br><span class="line">                batch_data = []</span><br><span class="line">        <span class="keyword">if</span> len(batch_data) &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">yield</span> make_test_array(batch_data)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> reader</span><br></pre></td></tr></table></figure>

<h1 id="单阶段目标检测模型YOLO-V3"><a href="#单阶段目标检测模型YOLO-V3" class="headerlink" title="单阶段目标检测模型YOLO-V3"></a>单阶段目标检测模型YOLO-V3</h1><p>上面介绍的R-CNN系列算法需要先产生候选区域，再对RoI做分类和位置坐标的预测，这类算法被称为两阶段目标检测算法。近几年，很多研究人员相继提出一系列单阶段的检测算法，只需要一个网络即可同时产生RoI并预测出物体的类别和位置坐标。</p>
<p>与R-CNN系列算法不同，YOLO-V3使用单个网络结构，在产生候选区域的同时即可预测出物体类别和位置，不需要分成两阶段来完成检测任务。另外，YOLO-V3算法产生的预测框数目比Faster-RCNN少很多。Faster-RCNN中每个真实框可能对应多个标签为正的候选区域，而YOLO-V3里面每个真实框只对应一个正的候选区域。这些特性使得YOLO-V3算法具有更快的速度，能到达实时响应的水平。</p>
<p>Joseph Redmon等人在2015年提出YOLO（You Only Look Once，YOLO）算法，通常也被称为YOLO V1；2016年，他们对算法进行改进，又提出YOLO V2版本；2018年发展出YOLO V3版本。</p>
<p>主要涵盖如下内容：</p>
<ul>
<li>YOLO-V3模型设计思想</li>
<li>产生候选区域<ul>
<li>生成锚框</li>
<li>生成预测框</li>
<li>标注候选区域</li>
</ul>
</li>
<li>卷积神经网络提取特征</li>
<li>建立损失函数<ul>
<li>获取样本标签</li>
<li>建立各项损失函数</li>
</ul>
</li>
<li>多层级检测</li>
<li>预测输出<ul>
<li>计算预测框得分和位置</li>
<li>非极大值抑制</li>
</ul>
</li>
</ul>
<h2 id="YOLO-V3-模型设计思想"><a href="#YOLO-V3-模型设计思想" class="headerlink" title="YOLO-V3 模型设计思想"></a>YOLO-V3 模型设计思想</h2><p>YOLO V3算法的基本思想可以分成两部分：</p>
<ul>
<li>按一定规则在图片上产生一系列的候选区域，然后根据这些候选区域与图片上物体真实框之间的位置关系对候选区域进行标注。跟真实框足够接近的那些候选区域会被标注为正样本，同时将真实框的位置作为正样本的位置目标。偏离真实框较大的那些候选区域则会被标注为负样本，负样本不需要预测位置或者类别。</li>
<li>使用卷积神经网络提取图片特征并对候选区域的位置和类别进行预测。这样每个预测框就可以看成是一个样本，根据真实框相对它的位置和类别进行了标注而获得标签值，通过网络模型预测其位置和类别，将网络预测值和标签值进行比较，就可以建立起损失函数。</li>
</ul>
<p>YOLO-V3算法训练过程的流程图如 <strong>图8</strong> 所示：</p>
<p><br></br></p>
<center><img src="https://ai-studio-static-online.cdn.bcebos.com/c21075a2450c4f64a2e52d3179a95c96d065c6a84ec344bb969fd4cac22df980" width = "800"></center>
<center><br>图8：YOLO-V3算法训练流程图 </br></center>
<br></br>


<ul>
<li><strong>图8</strong> 左边是输入图片，上半部分所示的过程是使用卷积神经网络对图片提取特征，随着网络不断向前传播，特征图的尺寸越来越小，每个像素点会代表更加抽象的特征模式，直到输出特征图，其尺寸减小为原图的$\frac{1}{32}$。</li>
<li><strong>图8</strong> 下半部分描述了生成候选区域的过程，首先将原图划分成多个小方块，每个小方块的大小是$32 \times 32$，然后以每个小方块为中心分别生成一系列锚框，整张图片都会被锚框覆盖到，在每个锚框的基础上产生一个与之对应的预测框，根据锚框和预测框与图片上物体真实框之间的位置关系，对这些预测框进行标注。</li>
<li>将上方支路中输出的特征图与下方支路中产生的预测框标签建立关联，创建损失函数，开启端到端的训练过程。</li>
</ul>
<p>接下来具体介绍流程中各节点的原理和代码实现。</p>
<h2 id="产生候选区域"><a href="#产生候选区域" class="headerlink" title="产生候选区域"></a>产生候选区域</h2><p>如何产生候选区域，是检测模型的核心设计方案。目前大多数基于卷积神经网络的模型所采用的方式大体如下：</p>
<ul>
<li>按一定的规则在图片上生成一系列位置固定的锚框，将这些锚框看作是可能的候选区域，</li>
<li>对锚框是否包含目标物体进行预测，如果包含目标物体，还需要预测所包含物体的类别，以及预测框相对于锚框位置需要调整的幅度。</li>
</ul>
<h3 id="生成锚框"><a href="#生成锚框" class="headerlink" title="生成锚框"></a>生成锚框</h3><p>将原始图片划分成$m\times n$个区域，如下图所示，原始图片高度H=640, 宽度W=480，如果我们选择小块区域的尺寸为$32 \times 32$，则m和n分别为：</p>
<p>$$m = \frac{640}{32} = 20$$</p>
<p>$$n = \frac{480}{32} = 15$$</p>
<p>如 <strong>图9</strong> 所示，将原始图像分成了20行15列小方块区域。</p>
<p><br></br></p>
<center><img src="https://ai-studio-static-online.cdn.bcebos.com/2dd1cbeb53644552a8cb38f3f834dbdda5046a489465454d93cdc88d1ce65ca5" width = "400"></center>
<center><br>图9：将图片划分成多个32x32的小方块 </br></center>
<br></br>


<p>YOLO-V3算法会在每个区域的中心，生成一系列锚框。为了展示方便，我们先在图中第十行第四列的小方块位置附近画出生成的锚框，如 <strong>图10</strong> 所示。</p>
<hr>
<p><strong>注意：</strong></p>
<p>这里为了跟程序中的编号对应，最上面的行号是第0行，最左边的列号是第0列**</p>
<hr>
<p><br></br></p>
<center><img src="https://ai-studio-static-online.cdn.bcebos.com/6dd42b9138364a379b6231ac2247d3cb449d612e17be4896986bca2703acbb29" width = "400"></center>
<center><br>图10：在第10行第4列的小方块区域生成3个锚框 </br></center>
<br></br>

<p><strong>图11</strong> 展示在每个区域附近都生成3个锚框，很多锚框堆叠在一起可能不太容易看清楚，但过程跟上面类似，只是需要以每个区域的中心点为中心，分别生成3个锚框。</p>
<p><br></br></p>
<center><img src="https://ai-studio-static-online.cdn.bcebos.com/0880c3b5ec2d40edb476f4fcbadd87aa9f37059cd24d4a1a9d37c627ce5f618a" width = "400"></center>
<center><br>图11：在每个小方块区域生成3个锚框 </br></center>
<br></br>


<h3 id="生成预测框"><a href="#生成预测框" class="headerlink" title="生成预测框"></a>生成预测框</h3><p>在前面已经指出，锚框的位置都是固定好的，不可能刚好跟物体边界框重合，需要在锚框的基础上进行位置的微调以生成预测框。预测框相对于锚框会有不同的中心位置和大小，采用什么方式能产生出在锚框上面微调得到的预测框呢，我们先来考虑如何生成其中心位置坐标。</p>
<p>比如上面图中在第10行第4列的小方块区域中心生成的一个锚框，如绿色虚线框所示。以小方格的宽度为单位长度，</p>
<p>此小方块区域左上角的位置坐标是：<br>$$c_x = 4$$<br>$$c_y = 10$$</p>
<p>此锚框的区域中心坐标是<br>$$center_x = c_x + 0.5 = 4.5$$<br>$$center_y = c_y + 0.5 = 10.5$$</p>
<p>可以通过下面的方式生成预测框的中心坐标：</p>
<p>$$b_x = c_x + \sigma(t_x)$$<br>$$b_y = c_y + \sigma(t_y)$$</p>
<p>其中$t_x$和$t_y$为实数，$\sigma(x)$是我们之前学过的Sigmoid函数，其定义如下：</p>
<p>$$\sigma(x) = \frac{1}{1 + exp(-x)}$$</p>
<p>由于Sigmoid的函数值总是在$0 \thicksim 1$之间，所以由上式计算出来的预测框中心点总是落在第十行第四列的小区域内部。</p>
<p>当$t_x=t_y=0$时，$b_x = c_x + 0.5$，$b_y = c_y + 0.5$，预测框中心与锚框中心重合，都是小区域的中心。</p>
<p>锚框的大小是预先设定好的，在模型中可以当作是超参数，下图中画出的锚框尺寸是</p>
<p>$$p_h = 350$$<br>$$p_w = 250$$</p>
<p>通过下面的公式生成预测框的大小：</p>
<p>$$b_h = p_h e^{t_h}$$<br>$$b_w = p_w e^{t_w}$$</p>
<p>如果$t_x=t_y=0, t_h=t_w=0$，则预测框跟锚框重合。</p>
<p>如果给$t_x, t_y, t_h, t_w$随机赋值如下：</p>
<p>$$t_x = 0.2,  t_y = 0.3, t_w = 0.1, t_h = -0.12$$</p>
<p>则可以得到预测框的坐标是(154.98, 357.44, 276.29, 310.42)，如 <strong>图12</strong> 中蓝色框所示。</p>
<ul>
<li>备注：这里坐标采用xywh的格式</li>
</ul>
<p><br></br></p>
<center><img src="https://ai-studio-static-online.cdn.bcebos.com/f4b33522eb5a45f0804b94a5c66b76a0a2d13345d6de499399580a031b6ccc74" width = "400"></center>
<center><br>图12：生成预测框 </br></center>
<br></br>

<p>这里我们会问：当$t_x, t_y, t_w, t_h$取值为多少的时候，预测框能够跟真实框重合？为了回答问题，只需要将上面预测框坐标中的$b_x, b_y, b_h, b_w$设置为真实框的位置，即可求解出t的数值。</p>
<p>令：<br>$$\sigma(t^<em>_x) + c_x = gt_x$$<br>$$\sigma(t^</em>_y) + c_y = gt_y$$<br>$$p_w e^{t^<em>_w} = gt_h$$<br>$$p_h e^{t^</em>_h} = gt_w$$</p>
<p>可以求解出 $(t^<em>_x, t^</em>_y, t^<em>_w, t^</em>_h)$</p>
<p>如果$t$是网络预测的输出值，将$t^<em>$作为目标值，以他们之间的差距作为损失函数，则可以建立起一个回归问题，通过学习网络参数，使得$t$足够接近$t^</em>$，从而能够求解出预测框的位置坐标跟大小。</p>
<p>预测框可以看作是在锚框基础上的一个微调，每个锚框会有一个跟它对应的预测框，我们需要确定上面计算式中的$t_x, t_y, t_w, t_h$，从而计算出与锚框对应的预测框的位置和形状。</p>
<h3 id="对候选区域进行标注"><a href="#对候选区域进行标注" class="headerlink" title="对候选区域进行标注"></a>对候选区域进行标注</h3><p>每个在区域可以产生3种不同形状的锚框，每个锚框都是一个可能的候选区域，对这些候选区域我们希望知道这么几件事情：</p>
<ul>
<li><p>锚框是否包含了物体，这可以看成是一个二分类问题，包含了物体和没有包含物体，我们使用标签objectness来表示。当锚框包含了物体时，objectness=1，表示预测框属于正类；当锚框不包含物体时，设置objectness=0，表示锚框属于负类。</p>
</li>
<li><p>如果锚框包含了物体，那么它对应的预测框的中心位置和大小应该是多少，或者说上面计算式中的$t_x, t_y, t_w, t_h$应该是多少。</p>
</li>
<li><p>如果锚框包含了物体，那么具体的具体类别是什么，这里使用变量label来表示其所属类别的标签。</p>
</li>
</ul>
<p>现在对于任意一个锚框，我们需要对它进行标注，也就是需要确定其对应的objectness, $(t_x, t_y, t_w, t_h)$和label，下面将分别讲述如何确定这三个标签的值。</p>
<h4 id="标注锚框是否包含物体的objectness标签"><a href="#标注锚框是否包含物体的objectness标签" class="headerlink" title="标注锚框是否包含物体的objectness标签"></a>标注锚框是否包含物体的objectness标签</h4><p>如 <strong>图13</strong> 所示，这里一共有3个目标，以最左边的人像为例，其真实框是$(40.93, 141.1, 186.06, 374.63)$。<br><br></br></p>
<center><img src="https://ai-studio-static-online.cdn.bcebos.com/f21679e68d2b496698ed788a16d4ea2e5bc6f82b253a44ef9508b6a4fc9b6be4" width = "600"></center>
<center><br>图13：选出与真实框中心位于同一区域的锚框 </br></center>
<br></br>

<p>真实框的中心点坐标是：</p>
<p>$$center_x = 40.93 + 186.06 / 2 = 133.96$$</p>
<p>$$center_y = 141.1 + 374.63 / 2 = 328.42$$</p>
<p>$$ i = 133.96 / 32 = 4.18625$$</p>
<p>$$ j = 328.42 / 32 = 10.263125$$</p>
<p>它落在了第10行第4列的小方块内，如图(b)所示。此小方块区域可以生成3个不同形状的锚框，其在图上的编号和大小分别是$A_1(116, 90), A_2(156, 198), A_3(373, 326)$。</p>
<p>用这3个不同形状的锚框跟真实框计算IoU，选出IoU最大的锚框。这里为了简化计算，只考虑锚框的形状，不考虑其跟真实框中心之间的偏移，具体计算结果如 <strong>图14</strong> 所示。</p>
<p><br></br></p>
<center><img src="https://ai-studio-static-online.cdn.bcebos.com/0487a67fe8704d959b7fd008e52b3942f9441f29d8e94481839ac5f209c538b3" width = "600"></center>
<center><br>图14：选出与真实框与锚框的IoU </br></center>
<br></br>

<p>其中跟真实框IoU最大的是锚框$A_3$，形状是$(373, 326)$，将它所对应的预测框的objectness标签设置为1，其所包括的物体类别就是真实框里面的物体所属类别。</p>
<p>依次可以找出其他几个真实框对应的IoU最大的锚框，然后将它们的预测框的objectness标签也都设置为1。这里一共有$20 \times 15 \times 3 = 900$个锚框，只有3个预测框会被标注为正。</p>
<p>由于每个真实框只对应一个objectness标签为正的预测框，如果有些预测框跟真实框之间的IoU很大，但并不是最大的那个，那么直接将其objectness标签设置为0当作负样本，可能并不妥当。为了避免这种情况，YOLO-V3算法设置了一个IoU阈值iou_thresh，当预测框的objectness不为1，但是其与某个真实框的IoU大于iou_thresh时，就将其objectness标签设置为-1，不参与损失函数的计算。</p>
<p>所有其他的预测框，其objectness标签均设置为0，表示负类。</p>
<p>对于objectness=1的预测框，需要进一步确定其位置和包含物体的具体分类标签，但是对于objectness=0或者-1的预测框，则不用管他们的位置和类别。</p>
<h4 id="标注预测框的位置坐标标签"><a href="#标注预测框的位置坐标标签" class="headerlink" title="标注预测框的位置坐标标签"></a>标注预测框的位置坐标标签</h4><p>当锚框objectness=1时，需要确定预测框位置相对于它微调的幅度，也就是锚框的位置标签。</p>
<p>在前面我们已经问过这样一个问题：当$t_x, t_y, t_w, t_h$取值为多少的时候，预测框能够跟真实框重合？其做法是将预测框坐标中的$b_x, b_y, b_h, b_w$设置为真实框的坐标，即可求解出t的数值。</p>
<p>令：<br>$$\sigma(t^<em>_x) + c_x = gt_x$$<br>$$\sigma(t^</em>_y) + c_y = gt_y$$<br>$$p_w e^{t^<em>_w} = gt_w$$<br>$$p_h e^{t^</em>_h} = gt_h$$</p>
<p>对于$t_x^<em>$和$t_y^</em>$，由于Sigmoid的反函数不好计算，我们直接将$\sigma(t^<em>_x)$和$\sigma(t^</em>_y)$作为回归的目标</p>
<p>$$d_x^* = \sigma(t^*_x) = gt_x - c_x$$</p>
<p>$$d_y^* = \sigma(t^*_y) = gt_y - c_y$$</p>
<p>$$t^*_w = log(\frac{gt_w}{p_w})$$</p>
<p>$$t^*_h = log(\frac{gt_h}{p_h})$$</p>
<p>如果$(t_x, t_y, t_h, t_w)$是网络预测的输出值，将$(d_x^<em>, d_y^</em>, t_w^<em>, t_h^</em>)$作为$(\sigma(t_x), \sigma(t_y), t_h, t_w)$的目标值，以它们之间的差距作为损失函数，则可以建立起一个回归问题，通过学习网络参数，使得$t$足够接近$t^*$，从而能够求解出预测框的位置。</p>
<h4 id="标注锚框包含物体类别的标签"><a href="#标注锚框包含物体类别的标签" class="headerlink" title="标注锚框包含物体类别的标签"></a>标注锚框包含物体类别的标签</h4><p>对于objectness=1的锚框，需要确定其具体类别。正如上面所说，objectness标注为1的锚框，会有一个真实框跟它对应，该锚框所属物体类别，即是其所对应的真实框包含的物体类别。这里使用one-hot向量来表示类别标签label。比如一共有10个分类，而真实框里面包含的物体类别是第2类，则label为$(0,1,0,0,0,0,0,0,0,0)$</p>
<p>对上述步骤进行总结，标注的流程如 <strong>图15</strong> 所示。<br><br></br></p>
<center><img src="https://ai-studio-static-online.cdn.bcebos.com/b7b9be40003947aa8bff8e72b84ee15033c7b3b1b61043eeb9b9c185aa83a210" width = "720"></center>
<center><br>图15：标注流程示意图 </br></center>
<br></br>

<p>通过这种方式，我们在每个小方块区域都生成了一系列的锚框作为候选区域，并且根据图片上真实物体的位置，标注出了每个候选区域对应的objectness标签、位置需要调整的幅度以及包含的物体所属的类别。位置需要调整的幅度由4个变量描述$(t_x, t_y, t_w, t_h)$，objectness标签需要用一个变量描述$obj$，描述所属类别的变量长度等于类别数C。</p>
<p>对于每个锚框，模型需要预测输出$(t_x, t_y, t_w, t_h, P_{obj}, P_1, P_2,… , P_C)$，其中$P_{obj}$是锚框是否包含物体的概率，$P_1, P_2,… , P_C$则是锚框包含的物体属于每个类别的概率。接下来让我们一起学习如何通过卷积神经网络输出这样的预测值。</p>
<h3 id="标注锚框的具体程序"><a href="#标注锚框的具体程序" class="headerlink" title="标注锚框的具体程序"></a>标注锚框的具体程序</h3><p>上面描述了如何对预锚框进行标注，但读者可能仍然对里面的细节不太了解，下面将通过具体的程序完成这一步骤。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 标注预测框的objectness</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_objectness_label</span><span class="params">(img, gt_boxes, gt_labels, iou_threshold = <span class="number">0.7</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                         anchors = [<span class="number">116</span>, <span class="number">90</span>, <span class="number">156</span>, <span class="number">198</span>, <span class="number">373</span>, <span class="number">326</span>],</span></span></span><br><span class="line"><span class="function"><span class="params">                         num_classes=<span class="number">7</span>, downsample=<span class="number">32</span>)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    img 是输入的图像数据，形状是[N, C, H, W]</span></span><br><span class="line"><span class="string">    gt_boxes，真实框，维度是[N, 50, 4]，其中50是真实框数目的上限，当图片中真实框不足50个时，不足部分的坐标全为0</span></span><br><span class="line"><span class="string">              真实框坐标格式是xywh，这里使用相对值</span></span><br><span class="line"><span class="string">    gt_labels，真实框所属类别，维度是[N, 50]</span></span><br><span class="line"><span class="string">    iou_threshold，当预测框与真实框的iou大于iou_threshold时不将其看作是负样本</span></span><br><span class="line"><span class="string">    anchors，锚框可选的尺寸</span></span><br><span class="line"><span class="string">    anchor_masks，通过与anchors一起确定本层级的特征图应该选用多大尺寸的锚框</span></span><br><span class="line"><span class="string">    num_classes，类别数目</span></span><br><span class="line"><span class="string">    downsample，特征图相对于输入网络的图片尺寸变化的比例</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    img_shape = img.shape</span><br><span class="line">    batchsize = img_shape[<span class="number">0</span>]</span><br><span class="line">    num_anchors = len(anchors) // <span class="number">2</span></span><br><span class="line">    input_h = img_shape[<span class="number">2</span>]</span><br><span class="line">    input_w = img_shape[<span class="number">3</span>]</span><br><span class="line">    <span class="comment"># 将输入图片划分成num_rows x num_cols个小方块区域，每个小方块的边长是 downsample</span></span><br><span class="line">    <span class="comment"># 计算一共有多少行小方块</span></span><br><span class="line">    num_rows = input_h // downsample</span><br><span class="line">    <span class="comment"># 计算一共有多少列小方块</span></span><br><span class="line">    num_cols = input_w // downsample</span><br><span class="line"></span><br><span class="line">    label_objectness = np.zeros([batchsize, num_anchors, num_rows, num_cols])</span><br><span class="line">    label_classification = np.zeros([batchsize, num_anchors, num_classes, num_rows, num_cols])</span><br><span class="line">    label_location = np.zeros([batchsize, num_anchors, <span class="number">4</span>, num_rows, num_cols])</span><br><span class="line"></span><br><span class="line">    scale_location = np.ones([batchsize, num_anchors, num_rows, num_cols])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 对batchsize进行循环，依次处理每张图片</span></span><br><span class="line">    <span class="keyword">for</span> n <span class="keyword">in</span> range(batchsize):</span><br><span class="line">        <span class="comment"># 对图片上的真实框进行循环，依次找出跟真实框形状最匹配的锚框</span></span><br><span class="line">        <span class="keyword">for</span> n_gt <span class="keyword">in</span> range(len(gt_boxes[n])):</span><br><span class="line">            gt = gt_boxes[n][n_gt]</span><br><span class="line">            gt_cls = gt_labels[n][n_gt]</span><br><span class="line">            gt_center_x = gt[<span class="number">0</span>]</span><br><span class="line">            gt_center_y = gt[<span class="number">1</span>]</span><br><span class="line">            gt_width = gt[<span class="number">2</span>]</span><br><span class="line">            gt_height = gt[<span class="number">3</span>]</span><br><span class="line">            <span class="keyword">if</span> (gt_height &lt; <span class="number">1e-3</span>) <span class="keyword">or</span> (gt_height &lt; <span class="number">1e-3</span>):</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            i = int(gt_center_y * num_rows)</span><br><span class="line">            j = int(gt_center_x * num_cols)</span><br><span class="line">            ious = []</span><br><span class="line">            <span class="keyword">for</span> ka <span class="keyword">in</span> range(num_anchors):</span><br><span class="line">                bbox1 = [<span class="number">0.</span>, <span class="number">0.</span>, float(gt_width), float(gt_height)]</span><br><span class="line">                anchor_w = anchors[ka * <span class="number">2</span>]</span><br><span class="line">                anchor_h = anchors[ka * <span class="number">2</span> + <span class="number">1</span>]</span><br><span class="line">                bbox2 = [<span class="number">0.</span>, <span class="number">0.</span>, anchor_w/float(input_w), anchor_h/float(input_h)]</span><br><span class="line">                <span class="comment"># 计算iou</span></span><br><span class="line">                iou = box_iou_xywh(bbox1, bbox2)</span><br><span class="line">                ious.append(iou)</span><br><span class="line">            ious = np.array(ious)</span><br><span class="line">            inds = np.argsort(ious)</span><br><span class="line">            k = inds[<span class="number">-1</span>]</span><br><span class="line">            label_objectness[n, k, i, j] = <span class="number">1</span></span><br><span class="line">            c = gt_cls</span><br><span class="line">            label_classification[n, k, c, i, j] = <span class="number">1.</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># for those prediction bbox with objectness =1, set label of location</span></span><br><span class="line">            dx_label = gt_center_x * num_cols - j</span><br><span class="line">            dy_label = gt_center_y * num_rows - i</span><br><span class="line">            dw_label = np.log(gt_width * input_w / anchors[k*<span class="number">2</span>])</span><br><span class="line">            dh_label = np.log(gt_height * input_h / anchors[k*<span class="number">2</span> + <span class="number">1</span>])</span><br><span class="line">            label_location[n, k, <span class="number">0</span>, i, j] = dx_label</span><br><span class="line">            label_location[n, k, <span class="number">1</span>, i, j] = dy_label</span><br><span class="line">            label_location[n, k, <span class="number">2</span>, i, j] = dw_label</span><br><span class="line">            label_location[n, k, <span class="number">3</span>, i, j] = dh_label</span><br><span class="line">            <span class="comment"># scale_location用来调节不同尺寸的锚框对损失函数的贡献，作为加权系数和位置损失函数相乘</span></span><br><span class="line">            scale_location[n, k, i, j] = <span class="number">2.0</span> - gt_width * gt_height</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 目前根据每张图片上所有出现过的gt box，都标注出了objectness为正的预测框，剩下的预测框则默认objectness为0</span></span><br><span class="line">    <span class="comment"># 对于objectness为1的预测框，标出了他们所包含的物体类别，以及位置回归的目标</span></span><br><span class="line">    <span class="keyword">return</span> label_objectness.astype(<span class="string">'float32'</span>), label_location.astype(<span class="string">'float32'</span>), label_classification.astype(<span class="string">'float32'</span>), \</span><br><span class="line">             scale_location.astype(<span class="string">'float32'</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 读取数据</span></span><br><span class="line">reader = multithread_loader(<span class="string">'/home/aistudio/work/insects/train'</span>, batch_size=<span class="number">2</span>, mode=<span class="string">'train'</span>)</span><br><span class="line">img, gt_boxes, gt_labels, im_shape = next(reader())</span><br><span class="line"><span class="comment"># 计算出锚框对应的标签</span></span><br><span class="line">label_objectness, label_location, label_classification, scale_location = get_objectness_label(img,</span><br><span class="line">                                                                                              gt_boxes, gt_labels, </span><br><span class="line">                                                                                              iou_threshold = <span class="number">0.7</span>,</span><br><span class="line">                                                                                              anchors = [<span class="number">116</span>, <span class="number">90</span>, <span class="number">156</span>, <span class="number">198</span>, <span class="number">373</span>, <span class="number">326</span>],</span><br><span class="line">                                                                                              num_classes=<span class="number">7</span>, downsample=<span class="number">32</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">img.shape, gt_boxes.shape, gt_labels.shape, im_shape.shape</span><br></pre></td></tr></table></figure>

<pre><code>((2, 3, 448, 448), (2, 50, 4), (2, 50), (2, 2))</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">label_objectness.shape, label_location.shape, label_classification.shape, scale_location.shape</span><br></pre></td></tr></table></figure>

<pre><code>((2, 3, 14, 14), (2, 3, 4, 14, 14), (2, 3, 7, 14, 14), (2, 3, 14, 14))</code></pre><p>上面的程序实现了对锚框进行标注，对于每个真实框，选出了与它形状最匹配的锚框，将其objectness标注为1，并且将$[d_x^<em>, d_y^</em>, t_h^<em>, t_w^</em>]$作为正样本位置的标签，真实框包含的物体类别作为锚框的类别。而其余的锚框，objectness将被标注为0，无需标注出位置和类别的标签。</p>
<ul>
<li>注意：这里还遗留一个小问题，前面我们说了对于与真实框IoU较大的那些锚框，需要将其objectness标注为-1，不参与损失函数的计算。我们先将这个问题放一放，等到后面建立损失函数的时候再补上。</li>
</ul>
<h2 id="卷积神经网络提取特征"><a href="#卷积神经网络提取特征" class="headerlink" title="卷积神经网络提取特征"></a>卷积神经网络提取特征</h2><p>在上一节图像分类的课程中，我们已经学习过了通过卷积神经网络提取图像特征。通过连续使用多层卷积和池化等操作，能得到语义含义更加丰富的特征图。在检测问题中，也使用卷积神经网络逐层提取图像特征，通过最终的输出特征图来表征物体位置和类别等信息。</p>
<p>YOLO V3算法使用的骨干网络是Darknet53。Darknet53网络的具体结构如 <strong>图16</strong> 所示，在ImageNet图像分类任务上取得了很好的成绩。在检测任务中，将图中C0后面的平均池化、全连接层和Softmax去掉，保留从输入到C0部分的网络结构，作为检测模型的基础网络结构，也称为骨干网络。YOLO V3模型会在骨干网络的基础上，再添加检测相关的网络模块。</p>
<p><br></br></p>
<center><img src="https://ai-studio-static-online.cdn.bcebos.com/d59dd9da1c494016accd40c8f0a72a9908f06c5d2d9b42c4aaad815c14d4c8a1" width = "400"></center>
<center><br>图16：Darknet53网络结构 </br></center>
<br></br>

<p>下面的程序是Darknet53骨干网络的实现代码，这里将上图中C0、C1、C2所表示的输出数据取出，并查看它们的形状分别是，$C0 [1, 1024, 20, 20]$，$C1 [1, 512, 40, 40]$，$C2 [1, 256, 80, 80]$。</p>
<ul>
<li>名词解释：特征图的步幅(stride)</li>
</ul>
<p>在提取特征的过程中通常会使用步幅大于1的卷积或者池化，导致后面的特征图尺寸越来越小，特征图的步幅等于输入图片尺寸除以特征图尺寸。例如C0的尺寸是$20\times20$，原图尺寸是$640\times640$，则C0的步幅是$\frac{640}{20}=32$。同理，C1的步幅是16，C2的步幅是8。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> paddle.fluid <span class="keyword">as</span> fluid</span><br><span class="line"><span class="keyword">from</span> paddle.fluid.param_attr <span class="keyword">import</span> ParamAttr</span><br><span class="line"><span class="keyword">from</span> paddle.fluid.regularizer <span class="keyword">import</span> L2Decay</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> paddle.fluid.dygraph.nn <span class="keyword">import</span> Conv2D, BatchNorm</span><br><span class="line"><span class="keyword">from</span> paddle.fluid.dygraph.base <span class="keyword">import</span> to_variable</span><br><span class="line"></span><br><span class="line"><span class="comment"># YOLO-V3骨干网络结构Darknet53的实现代码</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConvBNLayer</span><span class="params">(fluid.dygraph.Layer)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    卷积 + 批归一化，BN层之后激活函数默认用leaky_relu</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,</span></span></span><br><span class="line"><span class="function"><span class="params">                 name_scope,</span></span></span><br><span class="line"><span class="function"><span class="params">                 ch_out,</span></span></span><br><span class="line"><span class="function"><span class="params">                 filter_size=<span class="number">3</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                 stride=<span class="number">1</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                 groups=<span class="number">1</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                 padding=<span class="number">0</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                 act=<span class="string">"leaky"</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                 is_test=True)</span>:</span></span><br><span class="line">        super(ConvBNLayer, self).__init__(name_scope)</span><br><span class="line"></span><br><span class="line">        self.conv = Conv2D(</span><br><span class="line">            self.full_name(),</span><br><span class="line">            num_filters=ch_out,</span><br><span class="line">            filter_size=filter_size,</span><br><span class="line">            stride=stride,</span><br><span class="line">            padding=padding,</span><br><span class="line">            groups=groups,</span><br><span class="line">            param_attr=ParamAttr(</span><br><span class="line">                initializer=fluid.initializer.Normal(<span class="number">0.</span>, <span class="number">0.02</span>)),</span><br><span class="line">            bias_attr=<span class="literal">False</span>,</span><br><span class="line">            act=<span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line">        self.batch_norm = BatchNorm(</span><br><span class="line">            self.full_name(),</span><br><span class="line">            num_channels=ch_out,</span><br><span class="line">            is_test=is_test,</span><br><span class="line">            param_attr=ParamAttr(</span><br><span class="line">                initializer=fluid.initializer.Normal(<span class="number">0.</span>, <span class="number">0.02</span>),</span><br><span class="line">                regularizer=L2Decay(<span class="number">0.</span>)),</span><br><span class="line">            bias_attr=ParamAttr(</span><br><span class="line">                initializer=fluid.initializer.Constant(<span class="number">0.0</span>),</span><br><span class="line">                regularizer=L2Decay(<span class="number">0.</span>)))</span><br><span class="line">        self.act = act</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, inputs)</span>:</span></span><br><span class="line">        out = self.conv(inputs)</span><br><span class="line">        out = self.batch_norm(out)</span><br><span class="line">        <span class="keyword">if</span> self.act == <span class="string">'leaky'</span>:</span><br><span class="line">            out = fluid.layers.leaky_relu(x=out, alpha=<span class="number">0.1</span>)</span><br><span class="line">        <span class="keyword">return</span> out</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DownSample</span><span class="params">(fluid.dygraph.Layer)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    下采样，图片尺寸减半，具体实现方式是使用stirde=2的卷积</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,</span></span></span><br><span class="line"><span class="function"><span class="params">                 name_scope,</span></span></span><br><span class="line"><span class="function"><span class="params">                 ch_out,</span></span></span><br><span class="line"><span class="function"><span class="params">                 filter_size=<span class="number">3</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                 stride=<span class="number">2</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                 padding=<span class="number">1</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                 is_test=True)</span>:</span></span><br><span class="line"></span><br><span class="line">        super(DownSample, self).__init__(name_scope)</span><br><span class="line"></span><br><span class="line">        self.conv_bn_layer = ConvBNLayer(</span><br><span class="line">            self.full_name(),</span><br><span class="line">            ch_out=ch_out,</span><br><span class="line">            filter_size=filter_size,</span><br><span class="line">            stride=stride,</span><br><span class="line">            padding=padding,</span><br><span class="line">            is_test=is_test)</span><br><span class="line">        self.ch_out = ch_out</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, inputs)</span>:</span></span><br><span class="line">        out = self.conv_bn_layer(inputs)</span><br><span class="line">        <span class="keyword">return</span> out</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BasicBlock</span><span class="params">(fluid.dygraph.Layer)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    基本残差块的定义，输入x经过两层卷积，然后接第二层卷积的输出和输入x相加</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name_scope, ch_out, is_test=True)</span>:</span></span><br><span class="line">        super(BasicBlock, self).__init__(name_scope)</span><br><span class="line"></span><br><span class="line">        self.conv1 = ConvBNLayer(</span><br><span class="line">            self.full_name(),</span><br><span class="line">            ch_out=ch_out,</span><br><span class="line">            filter_size=<span class="number">1</span>,</span><br><span class="line">            stride=<span class="number">1</span>,</span><br><span class="line">            padding=<span class="number">0</span>,</span><br><span class="line">            is_test=is_test</span><br><span class="line">            )</span><br><span class="line">        self.conv2 = ConvBNLayer(</span><br><span class="line">            self.full_name(),</span><br><span class="line">            ch_out=ch_out*<span class="number">2</span>,</span><br><span class="line">            filter_size=<span class="number">3</span>,</span><br><span class="line">            stride=<span class="number">1</span>,</span><br><span class="line">            padding=<span class="number">1</span>,</span><br><span class="line">            is_test=is_test</span><br><span class="line">            )</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, inputs)</span>:</span></span><br><span class="line">        conv1 = self.conv1(inputs)</span><br><span class="line">        conv2 = self.conv2(conv1)</span><br><span class="line">        out = fluid.layers.elementwise_add(x=inputs, y=conv2, act=<span class="literal">None</span>)</span><br><span class="line">        <span class="keyword">return</span> out</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LayerWarp</span><span class="params">(fluid.dygraph.Layer)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    添加多层残差块，组成Darknet53网络的一个层级</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name_scope, ch_out, count, is_test=True)</span>:</span></span><br><span class="line">        super(LayerWarp,self).__init__(name_scope)</span><br><span class="line"></span><br><span class="line">        self.basicblock0 = BasicBlock(self.full_name(),</span><br><span class="line">            ch_out,</span><br><span class="line">            is_test=is_test)</span><br><span class="line">        self.res_out_list = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,count):</span><br><span class="line">            res_out = self.add_sublayer(<span class="string">"basic_block_%d"</span> % (i), <span class="comment">#使用add_sublayer添加子层</span></span><br><span class="line">                BasicBlock(self.full_name(),</span><br><span class="line">                    ch_out,</span><br><span class="line">                    is_test=is_test))</span><br><span class="line">            self.res_out_list.append(res_out)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self,inputs)</span>:</span></span><br><span class="line">        y = self.basicblock0(inputs)</span><br><span class="line">        <span class="keyword">for</span> basic_block_i <span class="keyword">in</span> self.res_out_list:</span><br><span class="line">            y = basic_block_i(y)</span><br><span class="line">        <span class="keyword">return</span> y</span><br><span class="line"></span><br><span class="line">DarkNet_cfg = &#123;<span class="number">53</span>: ([<span class="number">1</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">8</span>, <span class="number">4</span>])&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DarkNet53_conv_body</span><span class="params">(fluid.dygraph.Layer)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,</span></span></span><br><span class="line"><span class="function"><span class="params">                 name_scope,</span></span></span><br><span class="line"><span class="function"><span class="params">                 is_test=True)</span>:</span></span><br><span class="line">        super(DarkNet53_conv_body, self).__init__(name_scope)</span><br><span class="line">        self.stages = DarkNet_cfg[<span class="number">53</span>]</span><br><span class="line">        self.stages = self.stages[<span class="number">0</span>:<span class="number">5</span>]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 第一层卷积</span></span><br><span class="line">        self.conv0 = ConvBNLayer(</span><br><span class="line">            self.full_name(),</span><br><span class="line">            ch_out=<span class="number">32</span>,</span><br><span class="line">            filter_size=<span class="number">3</span>,</span><br><span class="line">            stride=<span class="number">1</span>,</span><br><span class="line">            padding=<span class="number">1</span>,</span><br><span class="line">            is_test=is_test)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 下采样，使用stride=2的卷积来实现</span></span><br><span class="line">        self.downsample0 = DownSample(</span><br><span class="line">            self.full_name(),</span><br><span class="line">            ch_out=<span class="number">32</span> * <span class="number">2</span>,</span><br><span class="line">            is_test=is_test)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 添加各个层级的实现</span></span><br><span class="line">        self.darknet53_conv_block_list = []</span><br><span class="line">        self.downsample_list = []</span><br><span class="line">        <span class="keyword">for</span> i, stage <span class="keyword">in</span> enumerate(self.stages):</span><br><span class="line">            conv_block = self.add_sublayer(</span><br><span class="line">                <span class="string">"stage_%d"</span> % (i),</span><br><span class="line">                LayerWarp(self.full_name(),</span><br><span class="line">                <span class="number">32</span>*(<span class="number">2</span>**i),</span><br><span class="line">                stage,</span><br><span class="line">                is_test=is_test))</span><br><span class="line">            self.darknet53_conv_block_list.append(conv_block)</span><br><span class="line">        <span class="comment"># 两个层级之间使用DownSample将尺寸减半</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(self.stages) - <span class="number">1</span>):</span><br><span class="line">            downsample = self.add_sublayer(</span><br><span class="line">                <span class="string">"stage_%d_downsample"</span> % i,</span><br><span class="line">                DownSample(self.full_name(),</span><br><span class="line">                    ch_out = <span class="number">32</span>*(<span class="number">2</span>**(i+<span class="number">2</span>)),</span><br><span class="line">                    is_test=is_test))</span><br><span class="line">            self.downsample_list.append(downsample)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self,inputs)</span>:</span></span><br><span class="line">        out = self.conv0(inputs)</span><br><span class="line">        <span class="comment">#print("conv1:",out.numpy())</span></span><br><span class="line">        out = self.downsample0(out)</span><br><span class="line">        <span class="comment">#print("dy:",out.numpy())</span></span><br><span class="line">        blocks = []</span><br><span class="line">        <span class="keyword">for</span> i, conv_block_i <span class="keyword">in</span> enumerate(self.darknet53_conv_block_list): <span class="comment">#依次将各个层级作用在输入上面</span></span><br><span class="line">            out = conv_block_i(out)</span><br><span class="line">            blocks.append(out)</span><br><span class="line">            <span class="keyword">if</span> i &lt; len(self.stages) - <span class="number">1</span>:</span><br><span class="line">                out = self.downsample_list[i](out)</span><br><span class="line">        <span class="keyword">return</span> blocks[<span class="number">-1</span>:<span class="number">-4</span>:<span class="number">-1</span>] <span class="comment"># 将C0, C1, C2作为返回值</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看Darknet53网络输出特征图</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">with</span> fluid.dygraph.guard():</span><br><span class="line">    backbone = DarkNet53_conv_body(<span class="string">'yolov3_backbone'</span>, is_test=<span class="literal">False</span>)</span><br><span class="line">    x = np.random.randn(<span class="number">1</span>, <span class="number">3</span>, <span class="number">640</span>, <span class="number">640</span>).astype(<span class="string">'float32'</span>)</span><br><span class="line">    x = to_variable(x)</span><br><span class="line">    C0, C1, C2 = backbone(x)</span><br><span class="line">    print(C0.shape, C1.shape, C2.shape)</span><br></pre></td></tr></table></figure>

<pre><code>([1L, 1024L, 20L, 20L], [1L, 512L, 40L, 40L], [1L, 256L, 80L, 80L])</code></pre><p>上面这段示例代码，指定输入数据的形状是$(1, 3, 640, 640)$，则3个层级的输出特征图的形状分别是$C0 (1, 1024, 20, 20)$，$C1 (1, 1024, 40, 40)$和$C2 (1, 1024, 80, 80)$。</p>
<h2 id="根据输出特征图计算预测框位置和类别"><a href="#根据输出特征图计算预测框位置和类别" class="headerlink" title="根据输出特征图计算预测框位置和类别"></a>根据输出特征图计算预测框位置和类别</h2><p>YOLO-V3中对每个预测框计算逻辑如下：</p>
<ul>
<li><p>预测框是否包含物体。也可理解为objectness=1的概率是多少，可以用网络输出一个实数x，可以用Sigmoid(x)表示objectness为正的概率$P_{obj}$</p>
</li>
<li><p>预测物体位置和形状。物体位置和形状$t_x, t_y, t_w, t_h$可以用网络输出4个实数来表示$t_x, t_y, t_w, t_h$</p>
</li>
<li><p>预测物体类别。预测图像中物体的具体类别是什么，或者说其属于每个类别的概率分别是多少。总的类别数为C，需要预测物体属于每个类别的概率$(P_1, P_2, …, P_C)$，可以用网络输出C个实数$(x_1, x_2, …, x_C)$，对每个实数分别求Sigmoid函数，让$P_i = Sigmoid(x_i)$，则可以表示出物体属于每个类别的概率。</p>
</li>
</ul>
<p>对于一个预测框，网络需要输出$(5 + C)$个实数来表征它是否包含物体、位置和形状尺寸以及属于每个类别的概率。</p>
<p>由于我们在每个小方块区域都生成了K个预测框，则所有预测框一共需要网络输出的预测值数目是：</p>
<p>$$[K(5 + C)] \times m \times n $$</p>
<p>还有更重要的一点是网络输出必须要能区分出小方块区域的位置来，不能直接将特征图连接一个输出大小为$[K(5 + C)] \times m \times n$的全连接层。</p>
<h3 id="建立输出特征图与预测框之间的关联"><a href="#建立输出特征图与预测框之间的关联" class="headerlink" title="建立输出特征图与预测框之间的关联"></a>建立输出特征图与预测框之间的关联</h3><p>现在观察特征图，经过多次卷积核池化之后，其步幅stride=32，$640 \times 480$大小的输入图片变成了$20\times15$的特征图；而小方块区域的数目正好是$20\times15$，也就是说可以让特征图上每个像素点分别跟原图上一个小方块区域对应。这也是为什么我们最开始将小方块区域的尺寸设置为32的原因，这样可以巧妙的将小方块区域跟特征图上的像素点对应起来，解决了空间位置的对应关系。</p>
<p><br></br></p>
<center><img src="https://ai-studio-static-online.cdn.bcebos.com/93e251bb309b4bb7a2031466ac62647089dbb280f2e84d5aaa468a9944f4654c" width = "400"></center>
<center><br>图17：特征图C0与小方块区域形状对比 </br></center>
<br></br>

<p>下面需要将像素点$(i,j)$与第i行第j列的小方块区域所需要的预测值关联起来，每个小方块区域产生K个预测框，每个预测框需要$(5 + C)$个实数预测值，则每个像素点相对应的要有$K(5 + C)$个实数。为了解决这一问题，对特征图进行多次卷积，并将最终的输出通道数设置为$K(5 + C)$，即可将生成的特征图与每个预测框所需要的预测值巧妙的对应起来。</p>
<p>骨干网络的输出特征图是C0，下面的程序是对C0进行多次卷积以得到跟预测框相关的特征图P0。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 从骨干网络输出特征图C0得到跟预测相关的特征图P0</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">YoloDetectionBlock</span><span class="params">(fluid.dygraph.Layer)</span>:</span></span><br><span class="line">    <span class="comment"># define YOLO-V3 detection head</span></span><br><span class="line">    <span class="comment"># 使用多层卷积和BN提取特征</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,name_scope,channel,is_test=True)</span>:</span></span><br><span class="line">        super(YoloDetectionBlock, self).__init__(name_scope)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">assert</span> channel % <span class="number">2</span> == <span class="number">0</span>, \</span><br><span class="line">            <span class="string">"channel &#123;&#125; cannot be divided by 2"</span>.format(channel)</span><br><span class="line"></span><br><span class="line">        self.conv0 = ConvBNLayer(</span><br><span class="line">            self.full_name(),</span><br><span class="line">            ch_out=channel,</span><br><span class="line">            filter_size=<span class="number">1</span>,</span><br><span class="line">            stride=<span class="number">1</span>,</span><br><span class="line">            padding=<span class="number">0</span>,</span><br><span class="line">            is_test=is_test</span><br><span class="line">            )</span><br><span class="line">        self.conv1 = ConvBNLayer(</span><br><span class="line">            self.full_name(),</span><br><span class="line">            ch_out=channel*<span class="number">2</span>,</span><br><span class="line">            filter_size=<span class="number">3</span>,</span><br><span class="line">            stride=<span class="number">1</span>,</span><br><span class="line">            padding=<span class="number">1</span>,</span><br><span class="line">            is_test=is_test</span><br><span class="line">            )</span><br><span class="line">        self.conv2 = ConvBNLayer(</span><br><span class="line">            self.full_name(),</span><br><span class="line">            ch_out=channel,</span><br><span class="line">            filter_size=<span class="number">1</span>,</span><br><span class="line">            stride=<span class="number">1</span>,</span><br><span class="line">            padding=<span class="number">0</span>,</span><br><span class="line">            is_test=is_test</span><br><span class="line">            )</span><br><span class="line">        self.conv3 = ConvBNLayer(</span><br><span class="line">            self.full_name(),</span><br><span class="line">            ch_out=channel*<span class="number">2</span>,</span><br><span class="line">            filter_size=<span class="number">3</span>,</span><br><span class="line">            stride=<span class="number">1</span>,</span><br><span class="line">            padding=<span class="number">1</span>,</span><br><span class="line">            is_test=is_test</span><br><span class="line">            )</span><br><span class="line">        self.route = ConvBNLayer(</span><br><span class="line">            self.full_name(),</span><br><span class="line">            ch_out=channel,</span><br><span class="line">            filter_size=<span class="number">1</span>,</span><br><span class="line">            stride=<span class="number">1</span>,</span><br><span class="line">            padding=<span class="number">0</span>,</span><br><span class="line">            is_test=is_test</span><br><span class="line">            )</span><br><span class="line">        self.tip = ConvBNLayer(</span><br><span class="line">            self.full_name(),</span><br><span class="line">            ch_out=channel*<span class="number">2</span>,</span><br><span class="line">            filter_size=<span class="number">3</span>,</span><br><span class="line">            stride=<span class="number">1</span>,</span><br><span class="line">            padding=<span class="number">1</span>,</span><br><span class="line">            is_test=is_test</span><br><span class="line">            )</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, inputs)</span>:</span></span><br><span class="line">        out = self.conv0(inputs)</span><br><span class="line">        out = self.conv1(out)</span><br><span class="line">        out = self.conv2(out)</span><br><span class="line">        out = self.conv3(out)</span><br><span class="line">        route = self.route(out)</span><br><span class="line">        tip = self.tip(route)</span><br><span class="line">        <span class="keyword">return</span> route, tip</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">NUM_ANCHORS = <span class="number">3</span></span><br><span class="line">NUM_CLASSES = <span class="number">7</span></span><br><span class="line">num_filters=NUM_ANCHORS * (NUM_CLASSES + <span class="number">5</span>)</span><br><span class="line"><span class="keyword">with</span> fluid.dygraph.guard():</span><br><span class="line">    backbone = DarkNet53_conv_body(<span class="string">'yolov3_backbone'</span>, is_test=<span class="literal">False</span>)</span><br><span class="line">    detection = YoloDetectionBlock(<span class="string">'detection'</span>, channel=<span class="number">512</span>, is_test=<span class="literal">False</span>)</span><br><span class="line">    conv2d_pred = Conv2D(<span class="string">'out_pred'</span>, num_filters=num_filters,  filter_size=<span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">    x = np.random.randn(<span class="number">1</span>, <span class="number">3</span>, <span class="number">640</span>, <span class="number">640</span>).astype(<span class="string">'float32'</span>)</span><br><span class="line">    x = to_variable(x)</span><br><span class="line">    C0, C1, C2 = backbone(x)</span><br><span class="line">    route, tip = detection(C0)</span><br><span class="line">    P0 = conv2d_pred(tip)</span><br><span class="line">    </span><br><span class="line">    print(P0.shape)</span><br></pre></td></tr></table></figure>

<pre><code>[1L, 36L, 20L, 20L]</code></pre><p>如上面的代码所示，可以由特征图C0生成特征图P0，P0的形状是$[1, 36, 20, 20]$。每个小方块区域生成的锚框或者预测框的数量是3，物体类别数目是7，每个区域需要的预测值个数是$3 \times (5 + 7) = 36$，正好等于P0的输出通道数。</p>
<p><br></br></p>
<center><img src="https://ai-studio-static-online.cdn.bcebos.com/7a3bcb1ca5cc4def9d93749bd963b402bc97568e22d24bd2855b6844db0c450b" width = "800"></center>
<center><br>图18：特征图P0与候选区域的关联 </br></center>
<br></br>

<p>将$P0[t, 0:12, i, j]$与输入的第t张图片上小方块区域$(i, j)$第1个预测框所需要的12个预测值对应，$P0[t, 12:24, i, j]$与输入的第t张图片上小方块区域$(i, j)$第2个预测框所需要的12个预测值对应，$P0[t, 24:36, i, j]$与输入的第t张图片上小方块区域$(i, j)$第3个预测框所需要的12个预测值对应。</p>
<p>$P0[t, 0:4, i, j]$与输入的第t张图片上小方块区域$(i, j)$第1个预测框的位置对应，$P0[t, 4, i, j]$与输入的第t张图片上小方块区域$(i, j)$第1个预测框的objectness对应，$P0[t, 5:12, i, j]$与输入的第t张图片上小方块区域$(i, j)$第1个预测框的类别对应。</p>
<p>如 <strong>图18</strong> 所示，通过这种方式可以巧妙的将网络输出特征图，与每个小方块区域生成的预测框对应起来了。</p>
<h3 id="计算预测框是否包含物体的概率"><a href="#计算预测框是否包含物体的概率" class="headerlink" title="计算预测框是否包含物体的概率"></a>计算预测框是否包含物体的概率</h3><p>根据前面的分析，$P0[t, 4, i, j]$与输入的第t张图片上小方块区域$(i, j)$第1个预测框的objectness对应，$P0[t, 4+12, i, j]$与第2个预测框的objectness对应，…，则可以使用下面的程序将objectness相关的预测取出，并使用fluid.layers.sigmoid计算输出概率。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">NUM_ANCHORS = <span class="number">3</span></span><br><span class="line">NUM_CLASSES = <span class="number">7</span></span><br><span class="line">num_filters=NUM_ANCHORS * (NUM_CLASSES + <span class="number">5</span>)</span><br><span class="line"><span class="keyword">with</span> fluid.dygraph.guard():</span><br><span class="line">    backbone = DarkNet53_conv_body(<span class="string">'yolov3_backbone'</span>, is_test=<span class="literal">False</span>)</span><br><span class="line">    detection = YoloDetectionBlock(<span class="string">'detection'</span>, channel=<span class="number">512</span>, is_test=<span class="literal">False</span>)</span><br><span class="line">    conv2d_pred = Conv2D(<span class="string">'out_pred'</span>, num_filters=num_filters,  filter_size=<span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">    x = np.random.randn(<span class="number">1</span>, <span class="number">3</span>, <span class="number">640</span>, <span class="number">640</span>).astype(<span class="string">'float32'</span>)</span><br><span class="line">    x = to_variable(x)</span><br><span class="line">    C0, C1, C2 = backbone(x)</span><br><span class="line">    route, tip = detection(C0)</span><br><span class="line">    P0 = conv2d_pred(tip)</span><br><span class="line">    reshaped_p0 = fluid.layers.reshape(P0, [<span class="number">-1</span>, NUM_ANCHORS, NUM_CLASSES + <span class="number">5</span>, P0.shape[<span class="number">2</span>], P0.shape[<span class="number">3</span>]])</span><br><span class="line">    pred_objectness = reshaped_p0[:, :, <span class="number">4</span>, :, :]</span><br><span class="line">    pred_objectness_probability = fluid.layers.sigmoid(pred_objectness)</span><br><span class="line">    print(pred_objectness.shape, pred_objectness_probability.shape)</span><br></pre></td></tr></table></figure>

<pre><code>([1L, 3L, 20L, 20L], [1L, 3L, 20L, 20L])</code></pre><p>上面的输出程序显示，预测框是否包含物体的概率pred_objectness_probability，其数据形状是$[1, 3, 20, 20] $，与我们上面提到的预测框个数一致，数据大小在0～1之间，表示预测框为正样本的概率。</p>
<h3 id="计算预测框位置坐标"><a href="#计算预测框位置坐标" class="headerlink" title="计算预测框位置坐标"></a>计算预测框位置坐标</h3><p>$P0[t, 0:4, i, j]$与输入的第t张图片上小方块区域$(i, j)$第1个预测框的位置对应，$P0[t, 12:16, i, j]$与第2个预测框的位置对应，…，使用下面的程序可以从P0中取出跟预测框位置相关的预测值。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">NUM_ANCHORS = <span class="number">3</span></span><br><span class="line">NUM_CLASSES = <span class="number">7</span></span><br><span class="line">num_filters=NUM_ANCHORS * (NUM_CLASSES + <span class="number">5</span>)</span><br><span class="line"><span class="keyword">with</span> fluid.dygraph.guard():</span><br><span class="line">    backbone = DarkNet53_conv_body(<span class="string">'yolov3_backbone'</span>, is_test=<span class="literal">False</span>)</span><br><span class="line">    detection = YoloDetectionBlock(<span class="string">'detection'</span>, channel=<span class="number">512</span>, is_test=<span class="literal">False</span>)</span><br><span class="line">    conv2d_pred = Conv2D(<span class="string">'out_pred'</span>, num_filters=num_filters,  filter_size=<span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">    x = np.random.randn(<span class="number">1</span>, <span class="number">3</span>, <span class="number">640</span>, <span class="number">640</span>).astype(<span class="string">'float32'</span>)</span><br><span class="line">    x = to_variable(x)</span><br><span class="line">    C0, C1, C2 = backbone(x)</span><br><span class="line">    route, tip = detection(C0)</span><br><span class="line">    P0 = conv2d_pred(tip)</span><br><span class="line">    reshaped_p0 = fluid.layers.reshape(P0, [<span class="number">-1</span>, NUM_ANCHORS, NUM_CLASSES + <span class="number">5</span>, P0.shape[<span class="number">2</span>], P0.shape[<span class="number">3</span>]])</span><br><span class="line">    pred_objectness = reshaped_p0[:, :, <span class="number">4</span>, :, :]</span><br><span class="line">    pred_objectness_probability = fluid.layers.sigmoid(pred_objectness)</span><br><span class="line"></span><br><span class="line">    pred_location = reshaped_p0[:, :, <span class="number">0</span>:<span class="number">4</span>, :, :]</span><br><span class="line">    print(pred_location.shape)</span><br></pre></td></tr></table></figure>

<pre><code>[1L, 3L, 4L, 20L, 20L]</code></pre><p>网络输出值是$(t_x, t_y, t_h, t_w)$，还需要将其转化为$(x_1, y_1, x_2, y_2)$这种形式的坐标表示。Paddle里面有专门的API fluid.layers.yolo_box直接计算出结果，但为了给读者更清楚的展示算法的实现过程，我们使用Numpy来实现这一过程。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义Sigmoid函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sigmoid</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1.</span>/(<span class="number">1.0</span> + np.exp(-x))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将网络特征图输出的[tx, ty, th, tw]转化成预测框的坐标[x1, y1, x2, y2]</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_yolo_box_xxyy</span><span class="params">(pred, anchors, num_classes, downsample)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    pred是网络输出特征图转化成的numpy.ndarray</span></span><br><span class="line"><span class="string">    anchors 是一个list。表示锚框的大小，</span></span><br><span class="line"><span class="string">                例如 anchors = [116, 90, 156, 198, 373, 326]，表示有三个锚框，</span></span><br><span class="line"><span class="string">                第一个锚框大小[w, h]是[116, 90]，第二个锚框大小是[156, 198]，第三个锚框大小是[373, 326]</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    batchsize = pred.shape[<span class="number">0</span>]</span><br><span class="line">    num_rows = pred.shape[<span class="number">-2</span>]</span><br><span class="line">    num_cols = pred.shape[<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line">    input_h = num_rows * downsample</span><br><span class="line">    input_w = num_cols * downsample</span><br><span class="line"></span><br><span class="line">    num_anchors = len(anchors) // <span class="number">2</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># pred的形状是[N, C, H, W]，其中C = NUM_ANCHORS * (5 + NUM_CLASSES)</span></span><br><span class="line">    <span class="comment"># 对pred进行reshape</span></span><br><span class="line">    pred = pred.reshape([<span class="number">-1</span>, num_anchors, <span class="number">5</span>+num_classes, num_rows, num_cols])</span><br><span class="line">    pred_location = pred[:, :, <span class="number">0</span>:<span class="number">4</span>, :, :]</span><br><span class="line">    pred_location = np.transpose(pred_location, (<span class="number">0</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">2</span>))</span><br><span class="line">    anchors_this = []</span><br><span class="line">    <span class="keyword">for</span> ind <span class="keyword">in</span> range(num_anchors):</span><br><span class="line">        anchors_this.append([anchors[ind*<span class="number">2</span>], anchors[ind*<span class="number">2</span>+<span class="number">1</span>]])</span><br><span class="line">    anchors_this = np.array(anchors_this).astype(<span class="string">'float32'</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 最终输出数据保存在pred_box中，其形状是[N, H, W, NUM_ANCHORS, 4]，</span></span><br><span class="line">    <span class="comment"># 其中最后一个维度4代表位置的4个坐标</span></span><br><span class="line">    pred_box = np.zeros(pred_location.shape)</span><br><span class="line">    <span class="keyword">for</span> n <span class="keyword">in</span> range(batchsize):</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(num_rows):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(num_cols):</span><br><span class="line">                <span class="keyword">for</span> k <span class="keyword">in</span> range(num_anchors):</span><br><span class="line">                    pred_box[n, i, j, k, <span class="number">0</span>] = j</span><br><span class="line">                    pred_box[n, i, j, k, <span class="number">1</span>] = i</span><br><span class="line">                    pred_box[n, i, j, k, <span class="number">2</span>] = anchors_this[k][<span class="number">0</span>]</span><br><span class="line">                    pred_box[n, i, j, k, <span class="number">3</span>] = anchors_this[k][<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 这里使用相对坐标，pred_box的输出元素数值在0.~1.0之间</span></span><br><span class="line">    pred_box[:, :, :, :, <span class="number">0</span>] = (sigmoid(pred_location[:, :, :, :, <span class="number">0</span>]) + pred_box[:, :, :, :, <span class="number">0</span>]) / num_cols</span><br><span class="line">    pred_box[:, :, :, :, <span class="number">1</span>] = (sigmoid(pred_location[:, :, :, :, <span class="number">1</span>]) + pred_box[:, :, :, :, <span class="number">1</span>]) / num_rows</span><br><span class="line">    pred_box[:, :, :, :, <span class="number">2</span>] = np.exp(pred_location[:, :, :, :, <span class="number">2</span>]) * pred_box[:, :, :, :, <span class="number">2</span>] / input_w</span><br><span class="line">    pred_box[:, :, :, :, <span class="number">3</span>] = np.exp(pred_location[:, :, :, :, <span class="number">3</span>]) * pred_box[:, :, :, :, <span class="number">3</span>] / input_h</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 将坐标从xywh转化成xyxy</span></span><br><span class="line">    pred_box[:, :, :, :, <span class="number">0</span>] = pred_box[:, :, :, :, <span class="number">0</span>] - pred_box[:, :, :, :, <span class="number">2</span>] / <span class="number">2.</span></span><br><span class="line">    pred_box[:, :, :, :, <span class="number">1</span>] = pred_box[:, :, :, :, <span class="number">1</span>] - pred_box[:, :, :, :, <span class="number">3</span>] / <span class="number">2.</span></span><br><span class="line">    pred_box[:, :, :, :, <span class="number">2</span>] = pred_box[:, :, :, :, <span class="number">0</span>] + pred_box[:, :, :, :, <span class="number">2</span>]</span><br><span class="line">    pred_box[:, :, :, :, <span class="number">3</span>] = pred_box[:, :, :, :, <span class="number">1</span>] + pred_box[:, :, :, :, <span class="number">3</span>]</span><br><span class="line"></span><br><span class="line">    pred_box = np.clip(pred_box, <span class="number">0.</span>, <span class="number">1.0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> pred_box</span><br></pre></td></tr></table></figure>

<p>通过调用上面定义的get_yolo_box_xxyy函数，可以从P0计算出预测框坐标来，具体程序如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">NUM_ANCHORS = <span class="number">3</span></span><br><span class="line">NUM_CLASSES = <span class="number">7</span></span><br><span class="line">num_filters=NUM_ANCHORS * (NUM_CLASSES + <span class="number">5</span>)</span><br><span class="line"><span class="keyword">with</span> fluid.dygraph.guard():</span><br><span class="line">    backbone = DarkNet53_conv_body(<span class="string">'yolov3_backbone'</span>, is_test=<span class="literal">False</span>)</span><br><span class="line">    detection = YoloDetectionBlock(<span class="string">'detection'</span>, channel=<span class="number">512</span>, is_test=<span class="literal">False</span>)</span><br><span class="line">    conv2d_pred = Conv2D(<span class="string">'out_pred'</span>, num_filters=num_filters,  filter_size=<span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">    x = np.random.randn(<span class="number">1</span>, <span class="number">3</span>, <span class="number">640</span>, <span class="number">640</span>).astype(<span class="string">'float32'</span>)</span><br><span class="line">    x = to_variable(x)</span><br><span class="line">    C0, C1, C2 = backbone(x)</span><br><span class="line">    route, tip = detection(C0)</span><br><span class="line">    P0 = conv2d_pred(tip)</span><br><span class="line">    reshaped_p0 = fluid.layers.reshape(P0, [<span class="number">-1</span>, NUM_ANCHORS, NUM_CLASSES + <span class="number">5</span>, P0.shape[<span class="number">2</span>], P0.shape[<span class="number">3</span>]])</span><br><span class="line">    pred_objectness = reshaped_p0[:, :, <span class="number">4</span>, :, :]</span><br><span class="line">    pred_objectness_probability = fluid.layers.sigmoid(pred_objectness)</span><br><span class="line"></span><br><span class="line">    pred_location = reshaped_p0[:, :, <span class="number">0</span>:<span class="number">4</span>, :, :]</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># anchors包含了预先设定好的锚框尺寸</span></span><br><span class="line">    anchors = [<span class="number">116</span>, <span class="number">90</span>, <span class="number">156</span>, <span class="number">198</span>, <span class="number">373</span>, <span class="number">326</span>]</span><br><span class="line">    <span class="comment"># downsample是特征图P0的步幅</span></span><br><span class="line">    pred_boxes = get_yolo_box_xxyy(P0.numpy(), anchors, num_classes=<span class="number">7</span>, downsample=<span class="number">32</span>) <span class="comment"># 由输出特征图P0计算预测框位置坐标</span></span><br><span class="line">    print(pred_boxes.shape)</span><br></pre></td></tr></table></figure>

<pre><code>(1, 20, 20, 3, 4)</code></pre><p>上面程序计算出来的pred_boxes的形状是$[N, H, W, num_anchors, 4]$，坐标格式是$[x_1, y_1, x_2, y_2]$，数值在0~1之间，表示相对坐标。</p>
<h3 id="计算物体属于每个类别概率"><a href="#计算物体属于每个类别概率" class="headerlink" title="计算物体属于每个类别概率"></a>计算物体属于每个类别概率</h3><p>$P0[t, 5:12, i, j]$与输入的第t张图片上小方块区域$(i, j)$第1个预测框包含物体的类别对应，$P0[t, 17:24, i, j]$与第2个预测框的类别对应，…，使用下面的程序可以从P0中取出那些跟预测框类别相关的预测值。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">NUM_ANCHORS = <span class="number">3</span></span><br><span class="line">NUM_CLASSES = <span class="number">7</span></span><br><span class="line">num_filters=NUM_ANCHORS * (NUM_CLASSES + <span class="number">5</span>)</span><br><span class="line"><span class="keyword">with</span> fluid.dygraph.guard():</span><br><span class="line">    backbone = DarkNet53_conv_body(<span class="string">'yolov3_backbone'</span>, is_test=<span class="literal">False</span>)</span><br><span class="line">    detection = YoloDetectionBlock(<span class="string">'detection'</span>, channel=<span class="number">512</span>, is_test=<span class="literal">False</span>)</span><br><span class="line">    conv2d_pred = Conv2D(<span class="string">'out_pred'</span>, num_filters=num_filters,  filter_size=<span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">    x = np.random.randn(<span class="number">1</span>, <span class="number">3</span>, <span class="number">640</span>, <span class="number">640</span>).astype(<span class="string">'float32'</span>)</span><br><span class="line">    x = to_variable(x)</span><br><span class="line">    C0, C1, C2 = backbone(x)</span><br><span class="line">    route, tip = detection(C0)</span><br><span class="line">    P0 = conv2d_pred(tip)</span><br><span class="line">    reshaped_p0 = fluid.layers.reshape(P0, [<span class="number">-1</span>, NUM_ANCHORS, NUM_CLASSES + <span class="number">5</span>, P0.shape[<span class="number">2</span>], P0.shape[<span class="number">3</span>]])</span><br><span class="line">    <span class="comment"># 取出与objectness相关的预测值</span></span><br><span class="line">    pred_objectness = reshaped_p0[:, :, <span class="number">4</span>, :, :]</span><br><span class="line">    pred_objectness_probability = fluid.layers.sigmoid(pred_objectness)</span><br><span class="line">    <span class="comment"># 取出与位置相关的预测值</span></span><br><span class="line">    pred_location = reshaped_p0[:, :, <span class="number">0</span>:<span class="number">4</span>, :, :]</span><br><span class="line">    <span class="comment"># 取出与类别相关的预测值</span></span><br><span class="line">    pred_classification = reshaped_p0[:, :, <span class="number">5</span>:<span class="number">5</span>+NUM_CLASSES, :, :]</span><br><span class="line">    pred_classification_probability = fluid.layers.sigmoid(pred_classification)</span><br><span class="line">    print(pred_classification.shape)</span><br></pre></td></tr></table></figure>

<pre><code>[1L, 3L, 7L, 20L, 20L]</code></pre><p>上面的程序通过P0计算出了预测框包含的物体所属类别的概率，pred_classification_probability的形状是$[1, 3, 7, 20, 20]$，数值在0~1之间。</p>
<h2 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h2><p>上面一小节从概念上将输出特征图上的像素点与预测框关联起来了，那么要对神经网络进行求解，还必须从数学上将网络输出和预测框关联起来，也就是要建立起损失函数跟网络输出之间的关系。下面讨论如何建立起YOLO-V3的损失函数。</p>
<p>对于每个预测框，YOLO-V3模型会建立三种类型的损失函数：</p>
<ul>
<li><p>表征是否包含目标物体的损失函数，通过pred_objectness和label_objectness计算</p>
<pre><code>loss_obj = fluid.layers.sigmoid_cross_entropy_with_logits(pred_objectness, label_objectness)</code></pre></li>
<li><p>表征物体位置的损失函数，通过pred_location和label_location计算</p>
<pre><code>pred_location_x = pred_location[:, :, 0, :, :]
pred_location_y = pred_location[:, :, 1, :, :]
pred_location_w = pred_location[:, :, 2, :, :]
pred_location_h = pred_location[:, :, 3, :, :]
loss_location_x = fluid.layers.sigmoid_cross_entropy_with_logits(pred_location_x, label_location_x)
loss_location_y = fluid.layers.sigmoid_cross_entropy_with_logits(pred_location_y, label_location_y)
loss_location_w = fluid.layers.abs(pred_location_w - label_location_w)
loss_location_h = fluid.layers.abs(pred_location_h - label_location_h)
loss_location = loss_location_x + loss_location_y + loss_location_w + loss_location_h</code></pre></li>
<li><p>表征物体类别的损失函数，通过pred_classification和label_classification计算</p>
<pre><code>loss_obj = fluid.layers.sigmoid_cross_entropy_with_logits(pred_classification, label_classification)</code></pre></li>
</ul>
<p>在前面几个小节中我们已经知道怎么计算这些预测值和标签了，但是遗留了一个小问题，就是没有标注出哪些锚框的objectness为-1。为了完成这一步，我们需要计算出所有预测框跟真实框之间的IoU，然后把那些IoU大于阈值的真实框挑选出来。实现代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 挑选出跟真实框IoU大于阈值的预测框</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_iou_above_thresh_inds</span><span class="params">(pred_box, gt_boxes, iou_threshold)</span>:</span></span><br><span class="line">    batchsize = pred_box.shape[<span class="number">0</span>]</span><br><span class="line">    num_rows = pred_box.shape[<span class="number">1</span>]</span><br><span class="line">    num_cols = pred_box.shape[<span class="number">2</span>]</span><br><span class="line">    num_anchors = pred_box.shape[<span class="number">3</span>]</span><br><span class="line">    ret_inds = np.zeros([batchsize, num_rows, num_cols, num_anchors])</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(batchsize):</span><br><span class="line">        pred_box_i = pred_box[i]</span><br><span class="line">        gt_boxes_i = gt_boxes[i]</span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> range(len(gt_boxes_i)): <span class="comment">#gt in gt_boxes_i:</span></span><br><span class="line">            gt = gt_boxes_i[k]</span><br><span class="line">            gtx_min = gt[<span class="number">0</span>] - gt[<span class="number">2</span>] / <span class="number">2.</span></span><br><span class="line">            gty_min = gt[<span class="number">1</span>] - gt[<span class="number">3</span>] / <span class="number">2.</span></span><br><span class="line">            gtx_max = gt[<span class="number">0</span>] + gt[<span class="number">2</span>] / <span class="number">2.</span></span><br><span class="line">            gty_max = gt[<span class="number">1</span>] + gt[<span class="number">3</span>] / <span class="number">2.</span></span><br><span class="line">            <span class="keyword">if</span> (gtx_max - gtx_min &lt; <span class="number">1e-3</span>) <span class="keyword">or</span> (gty_max - gty_min &lt; <span class="number">1e-3</span>):</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            x1 = np.maximum(pred_box_i[:, :, :, <span class="number">0</span>], gtx_min)</span><br><span class="line">            y1 = np.maximum(pred_box_i[:, :, :, <span class="number">1</span>], gty_min)</span><br><span class="line">            x2 = np.minimum(pred_box_i[:, :, :, <span class="number">2</span>], gtx_max)</span><br><span class="line">            y2 = np.minimum(pred_box_i[:, :, :, <span class="number">3</span>], gty_max)</span><br><span class="line">            intersection = np.maximum(x2 - x1, <span class="number">0.</span>) * np.maximum(y2 - y1, <span class="number">0.</span>)</span><br><span class="line">            s1 = (gty_max - gty_min) * (gtx_max - gtx_min)</span><br><span class="line">            s2 = (pred_box_i[:, :, :, <span class="number">2</span>] - pred_box_i[:, :, :, <span class="number">0</span>]) * (pred_box_i[:, :, :, <span class="number">3</span>] - pred_box_i[:, :, :, <span class="number">1</span>])</span><br><span class="line">            union = s2 + s1 - intersection</span><br><span class="line">            iou = intersection / union</span><br><span class="line">            above_inds = np.where(iou &gt; iou_threshold)</span><br><span class="line">            ret_inds[i][above_inds] = <span class="number">1</span></span><br><span class="line">    ret_inds = np.transpose(ret_inds, (<span class="number">0</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>))</span><br><span class="line">    <span class="keyword">return</span> ret_inds.astype(<span class="string">'bool'</span>)</span><br></pre></td></tr></table></figure>

<p>上面的函数可以得到哪些锚框的objectness需要被标注为-1，通过下面的程序，对label_objectness进行处理，将IoU大于阈值，但又不是正样本的那些锚框标注为-1。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">label_objectness_ignore</span><span class="params">(label_objectness, iou_above_thresh_indices)</span>:</span></span><br><span class="line">    <span class="comment"># 注意：这里不能简单的使用 label_objectness[iou_above_thresh_indices] = -1，</span></span><br><span class="line">    <span class="comment">#         这样可能会造成label_objectness为1的那些点被设置为-1了</span></span><br><span class="line">    <span class="comment">#         只有将那些被标注为0，且与真实框IoU超过阈值的预测框才被标注为-1</span></span><br><span class="line">    negative_indices = (label_objectness &lt; <span class="number">0.5</span>)</span><br><span class="line">    ignore_indices = negative_indices * iou_above_thresh_indices</span><br><span class="line">    label_objectness[ignore_indices] = <span class="number">-1</span></span><br><span class="line">    <span class="keyword">return</span> label_objectness</span><br></pre></td></tr></table></figure>

<p>下面通过调用这两个函数，实现如何将部分预测框的label_objectness设置为-1。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 读取数据</span></span><br><span class="line">reader = multithread_loader(<span class="string">'/home/aistudio/work/insects/train'</span>, batch_size=<span class="number">2</span>, mode=<span class="string">'train'</span>)</span><br><span class="line">img, gt_boxes, gt_labels, im_shape = next(reader())</span><br><span class="line"><span class="comment"># 计算出锚框对应的标签</span></span><br><span class="line">label_objectness, label_location, label_classification, scale_location = get_objectness_label(img,</span><br><span class="line">                                                                                              gt_boxes, gt_labels, </span><br><span class="line">                                                                                              iou_threshold = <span class="number">0.7</span>,</span><br><span class="line">                                                                                              anchors = [<span class="number">116</span>, <span class="number">90</span>, <span class="number">156</span>, <span class="number">198</span>, <span class="number">373</span>, <span class="number">326</span>],</span><br><span class="line">                                                                                              num_classes=<span class="number">7</span>, downsample=<span class="number">32</span>)</span><br><span class="line">NUM_ANCHORS = <span class="number">3</span></span><br><span class="line">NUM_CLASSES = <span class="number">7</span></span><br><span class="line">num_filters=NUM_ANCHORS * (NUM_CLASSES + <span class="number">5</span>)</span><br><span class="line"><span class="keyword">with</span> fluid.dygraph.guard():</span><br><span class="line">    backbone = DarkNet53_conv_body(<span class="string">'yolov3_backbone'</span>, is_test=<span class="literal">False</span>)</span><br><span class="line">    detection = YoloDetectionBlock(<span class="string">'detection'</span>, channel=<span class="number">512</span>, is_test=<span class="literal">False</span>)</span><br><span class="line">    conv2d_pred = Conv2D(<span class="string">'out_pred'</span>, num_filters=num_filters,  filter_size=<span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">    x = to_variable(img)</span><br><span class="line">    C0, C1, C2 = backbone(x)</span><br><span class="line">    route, tip = detection(C0)</span><br><span class="line">    P0 = conv2d_pred(tip)</span><br><span class="line">    <span class="comment"># anchors包含了预先设定好的锚框尺寸</span></span><br><span class="line">    anchors = [<span class="number">116</span>, <span class="number">90</span>, <span class="number">156</span>, <span class="number">198</span>, <span class="number">373</span>, <span class="number">326</span>]</span><br><span class="line">    <span class="comment"># downsample是特征图P0的步幅</span></span><br><span class="line">    pred_boxes = get_yolo_box_xxyy(P0.numpy(), anchors, num_classes=<span class="number">7</span>, downsample=<span class="number">32</span>)</span><br><span class="line">    iou_above_thresh_indices = get_iou_above_thresh_inds(pred_boxes, gt_boxes, iou_threshold=<span class="number">0.7</span>)</span><br><span class="line">    label_objectness = label_objectness_ignore(label_objectness, iou_above_thresh_indices)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">label_objectness.shape</span><br></pre></td></tr></table></figure>

<pre><code>(2, 3, 10, 10)</code></pre><p>使用这种方式，就可以将那些没有被标注为正样本，但又与真实框IoU比较大的样本objectness标签设置为-1了，不计算其对任何一种损失函数的贡献。</p>
<p>计算总的损失函数的代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_loss</span><span class="params">(output, label_objectness, label_location, label_classification, scales, num_anchors=<span class="number">3</span>, num_classes=<span class="number">7</span>)</span>:</span></span><br><span class="line">    <span class="comment"># 将output从[N, C, H, W]变形为[N, NUM_ANCHORS, NUM_CLASSES + 5, H, W]</span></span><br><span class="line">    reshaped_output = fluid.layers.reshape(output, [<span class="number">-1</span>, num_anchors, num_classes + <span class="number">5</span>, output.shape[<span class="number">2</span>], output.shape[<span class="number">3</span>]])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 从output中取出跟objectness相关的预测值</span></span><br><span class="line">    pred_objectness = reshaped_output[:, :, <span class="number">4</span>, :, :]</span><br><span class="line">    loss_objectness = fluid.layers.sigmoid_cross_entropy_with_logits(pred_objectness, label_objectness, ignore_index=<span class="number">-1</span>)</span><br><span class="line">    <span class="comment">## 对第1，2，3维求和</span></span><br><span class="line">    <span class="comment">#loss_objectness = fluid.layers.reduce_sum(loss_objectness, dim=[1,2,3], keep_dim=False)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># pos_samples 只有在正样本的地方取值为1.，其它地方取值全为0.</span></span><br><span class="line">    pos_objectness = label_objectness &gt; <span class="number">0</span></span><br><span class="line">    pos_samples = fluid.layers.cast(pos_objectness, <span class="string">'float32'</span>)</span><br><span class="line">    pos_samples.stop_gradient=<span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#从output中取出所有跟位置相关的预测值</span></span><br><span class="line">    tx = reshaped_output[:, :, <span class="number">0</span>, :, :]</span><br><span class="line">    ty = reshaped_output[:, :, <span class="number">1</span>, :, :]</span><br><span class="line">    tw = reshaped_output[:, :, <span class="number">2</span>, :, :]</span><br><span class="line">    th = reshaped_output[:, :, <span class="number">3</span>, :, :]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 从label_location中取出各个位置坐标的标签</span></span><br><span class="line">    dx_label = label_location[:, :, <span class="number">0</span>, :, :]</span><br><span class="line">    dy_label = label_location[:, :, <span class="number">1</span>, :, :]</span><br><span class="line">    tw_label = label_location[:, :, <span class="number">2</span>, :, :]</span><br><span class="line">    th_label = label_location[:, :, <span class="number">3</span>, :, :]</span><br><span class="line">    <span class="comment"># 构建损失函数</span></span><br><span class="line">    loss_location_x = fluid.layers.sigmoid_cross_entropy_with_logits(tx, dx_label)</span><br><span class="line">    loss_location_y = fluid.layers.sigmoid_cross_entropy_with_logits(ty, dy_label)</span><br><span class="line">    loss_location_w = fluid.layers.abs(tw - tw_label)</span><br><span class="line">    loss_location_h = fluid.layers.abs(th - th_label)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 计算总的位置损失函数</span></span><br><span class="line">    loss_location = loss_location_x + loss_location_y + loss_location_h + loss_location_w</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 乘以scales</span></span><br><span class="line">    loss_location = loss_location * scales</span><br><span class="line">    <span class="comment"># 只计算正样本的位置损失函数</span></span><br><span class="line">    loss_location = loss_location * pos_samples</span><br><span class="line"></span><br><span class="line">    <span class="comment">#从ooutput取出所有跟物体类别相关的像素点</span></span><br><span class="line">    pred_classification = reshaped_output[:, :, <span class="number">5</span>:<span class="number">5</span>+num_classes, :, :]</span><br><span class="line">    <span class="comment"># 计算分类相关的损失函数</span></span><br><span class="line">    loss_classification = fluid.layers.sigmoid_cross_entropy_with_logits(pred_classification, label_classification)</span><br><span class="line">    <span class="comment"># 将第2维求和</span></span><br><span class="line">    loss_classification = fluid.layers.reduce_sum(loss_classification, dim=<span class="number">2</span>, keep_dim=<span class="literal">False</span>)</span><br><span class="line">    <span class="comment"># 只计算objectness为正的样本的分类损失函数</span></span><br><span class="line">    loss_classification = loss_classification * pos_samples</span><br><span class="line">    total_loss = loss_objectness + loss_location + loss_classification</span><br><span class="line">    <span class="comment"># 对所有预测框的loss进行求和</span></span><br><span class="line">    total_loss = fluid.layers.reduce_sum(total_loss, dim=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], keep_dim=<span class="literal">False</span>)</span><br><span class="line">    <span class="comment"># 对所有样本求平均</span></span><br><span class="line">    total_loss = fluid.layers.reduce_mean(total_loss)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> total_loss</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 计算损失函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取数据</span></span><br><span class="line">reader = multithread_loader(<span class="string">'/home/aistudio/work/insects/train'</span>, batch_size=<span class="number">2</span>, mode=<span class="string">'train'</span>)</span><br><span class="line">img, gt_boxes, gt_labels, im_shape = next(reader())</span><br><span class="line"><span class="comment"># 计算出锚框对应的标签</span></span><br><span class="line">label_objectness, label_location, label_classification, scale_location = get_objectness_label(img,</span><br><span class="line">                                                                                              gt_boxes, gt_labels, </span><br><span class="line">                                                                                              iou_threshold = <span class="number">0.7</span>,</span><br><span class="line">                                                                                              anchors = [<span class="number">116</span>, <span class="number">90</span>, <span class="number">156</span>, <span class="number">198</span>, <span class="number">373</span>, <span class="number">326</span>],</span><br><span class="line">                                                                                              num_classes=<span class="number">7</span>, downsample=<span class="number">32</span>)</span><br><span class="line">NUM_ANCHORS = <span class="number">3</span></span><br><span class="line">NUM_CLASSES = <span class="number">7</span></span><br><span class="line">num_filters=NUM_ANCHORS * (NUM_CLASSES + <span class="number">5</span>)</span><br><span class="line"><span class="keyword">with</span> fluid.dygraph.guard():</span><br><span class="line">    backbone = DarkNet53_conv_body(<span class="string">'yolov3_backbone'</span>, is_test=<span class="literal">False</span>)</span><br><span class="line">    detection = YoloDetectionBlock(<span class="string">'detection'</span>, channel=<span class="number">512</span>, is_test=<span class="literal">False</span>)</span><br><span class="line">    conv2d_pred = Conv2D(<span class="string">'out_pred'</span>, num_filters=num_filters,  filter_size=<span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">    x = to_variable(img)</span><br><span class="line">    C0, C1, C2 = backbone(x)</span><br><span class="line">    route, tip = detection(C0)</span><br><span class="line">    P0 = conv2d_pred(tip)</span><br><span class="line">    <span class="comment"># anchors包含了预先设定好的锚框尺寸</span></span><br><span class="line">    anchors = [<span class="number">116</span>, <span class="number">90</span>, <span class="number">156</span>, <span class="number">198</span>, <span class="number">373</span>, <span class="number">326</span>]</span><br><span class="line">    <span class="comment"># downsample是特征图P0的步幅</span></span><br><span class="line">    pred_boxes = get_yolo_box_xxyy(P0.numpy(), anchors, num_classes=<span class="number">7</span>, downsample=<span class="number">32</span>)</span><br><span class="line">    iou_above_thresh_indices = get_iou_above_thresh_inds(pred_boxes, gt_boxes, iou_threshold=<span class="number">0.7</span>)</span><br><span class="line">    label_objectness = label_objectness_ignore(label_objectness, iou_above_thresh_indices)</span><br><span class="line">    </span><br><span class="line">    label_objectness = to_variable(label_objectness)</span><br><span class="line">    label_location = to_variable(label_location)</span><br><span class="line">    label_classification = to_variable(label_classification)</span><br><span class="line">    scales = to_variable(scale_location)</span><br><span class="line">    label_objectness.stop_gradient=<span class="literal">True</span></span><br><span class="line">    label_location.stop_gradient=<span class="literal">True</span></span><br><span class="line">    label_classification.stop_gradient=<span class="literal">True</span></span><br><span class="line">    scales.stop_gradient=<span class="literal">True</span></span><br><span class="line">    </span><br><span class="line">    total_loss = get_loss(P0, label_objectness, label_location, label_classification, scales,</span><br><span class="line">                              num_anchors=NUM_ANCHORS, num_classes=NUM_CLASSES)</span><br><span class="line">    total_loss_data = total_loss.numpy()</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">total_loss_data</span><br></pre></td></tr></table></figure>

<pre><code>array([623.6282], dtype=float32)</code></pre><p>上面的程序计算出了总的损失函数，看到这里，读者已经了解到了YOLO-V3算法的大部分内容，包括如何生成锚框、给锚框打上标签、通过卷积神经网络提取特征、将输出特征图跟预测框相关联、建立起损失函数。</p>
<h2 id="多尺度检测"><a href="#多尺度检测" class="headerlink" title="多尺度检测"></a>多尺度检测</h2><p>目前我们计算损失函数是在特征图P0的基础上进行的，它的步幅stride=32。特征图的尺寸比较小，像素点数目比较少，每个像素点的感受野很大，具有非常丰富的高层级语义信息，可能比较容易检测到较大的目标。为了能够检测到尺寸较小的那些目标，需要在尺寸较大的特征图上面建立预测输出。如果我们在C2或者C1这种层级的特征图上直接产生预测输出，可能面临新的问题，它们没有经过充分的特征提取，像素点包含的语义信息不够丰富，有可能难以提取到有效的特征模式。在目标检测中，解决这一问题的方式是，将高层级的特征图尺寸放大之后跟低层级的特征图进行融合，得到的新特征图既能包含丰富的语义信息，又具有较多的像素点，能够描述更加精细的结构。</p>
<p>具体的网络实现方式如 <strong>图19</strong> 所示：</p>
<p><br></br></p>
<center><img src="https://ai-studio-static-online.cdn.bcebos.com/1ec38428c95d4ab4a133dd4262f130eddeee0befa6dd40f599b9ce562f442685" width = "800"></center>
<center><br>图19：生成多层级的输出特征图P0、P1、P2 </br></center>
<br></br>

<p>YOLO-V3在每个区域的中心位置产生3个锚框，在3个层级的特征图上产生锚框的大小分别为P2 [(10×13),(16×30),(33×23)]，P1 [(30×61),(62×45),(59× 119)]，P0[(116 × 90), (156 × 198), (373 × 326]。越往后的特征图上用到的锚框尺寸也越大，能捕捉到大尺寸目标的信息；越往前的特征图上锚框尺寸越小，能捕捉到小尺寸目标的信息。</p>
<p>因为有多尺度的检测，所以需要对上面的代码进行较大的修改，而且实现过程也略显繁琐，所以推荐大家直接使用Paddle提供的API fluid.layers.yolov3_loss，其具体说明如下：</p>
<ul>
<li>fluid.layers.yolov3_loss(x, gt_box, gt_label, anchors, anchor_mask, class_num, ignore_thresh, downsample_ratio, gt_score=None, use_label_smooth=True, name=None))<ul>
<li>x: 输入的图像数据</li>
<li>gt_box: 真实框</li>
<li>gt_label: 真实框标签</li>
<li>anchors: 使用到的anchor的尺寸，如[10, 13, 16, 30, 33, 23, 30, 61, 62, 45, 59, 119, 116, 90, 156, 198, 373, 326]</li>
<li>anchor_mask: 每个层级上使用的anchor的掩码，[[6, 7, 8], [3, 4, 5], [0, 1, 2]]</li>
<li>class_num，物体类别数，AI识虫数据集为7</li>
<li>ignore_thresh，预测框与真实框IoU阈值超过ignore_thresh时，不作为负样本，YOLO-V3模型里设置为0.7</li>
<li>downsample_ratio，特征图P0的下采样比例，使用Darknet53骨干网络时为32</li>
<li>gt_score，真实框的置信度，在使用了mixup技巧时会用到</li>
<li>use_label_smooth，一种训练技巧，不使用就设置为False</li>
<li>name，该层的名字，比如’yolov3_loss’，可以不设置</li>
</ul>
</li>
</ul>
<p>对于使用了多层级特征图产生预测框的方法，其具体实现代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义上采样模块</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Upsample</span><span class="params">(fluid.dygraph.Layer)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name_scope, scale=<span class="number">2</span>)</span>:</span></span><br><span class="line">        super(Upsample,self).__init__(name_scope)</span><br><span class="line">        self.scale = scale</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, inputs)</span>:</span></span><br><span class="line">        <span class="comment"># get dynamic upsample output shape</span></span><br><span class="line">        shape_nchw = fluid.layers.shape(inputs)</span><br><span class="line">        shape_hw = fluid.layers.slice(shape_nchw, axes=[<span class="number">0</span>], starts=[<span class="number">2</span>], ends=[<span class="number">4</span>])</span><br><span class="line">        shape_hw.stop_gradient = <span class="literal">True</span></span><br><span class="line">        in_shape = fluid.layers.cast(shape_hw, dtype=<span class="string">'int32'</span>)</span><br><span class="line">        out_shape = in_shape * self.scale</span><br><span class="line">        out_shape.stop_gradient = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># reisze by actual_shape</span></span><br><span class="line">        out = fluid.layers.resize_nearest(</span><br><span class="line">            input=inputs, scale=self.scale, actual_shape=out_shape)</span><br><span class="line">        <span class="keyword">return</span> out</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义YOLO-V3模型</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">YOLOv3</span><span class="params">(fluid.dygraph.Layer)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,name_scope, num_classes=<span class="number">7</span>, is_train=True)</span>:</span></span><br><span class="line">        super(YOLOv3,self).__init__(name_scope)</span><br><span class="line"></span><br><span class="line">        self.is_train = is_train</span><br><span class="line">        self.num_classes = num_classes</span><br><span class="line">        <span class="comment"># 提取图像特征的骨干代码</span></span><br><span class="line">        self.block = DarkNet53_conv_body(self.full_name(),</span><br><span class="line">                                         is_test = <span class="keyword">not</span> self.is_train)</span><br><span class="line">        self.block_outputs = []</span><br><span class="line">        self.yolo_blocks = []</span><br><span class="line">        self.route_blocks_2 = []</span><br><span class="line">        <span class="comment"># 生成3个层级的特征图P0, P1, P2</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">            <span class="comment"># 添加从ci生成ri和ti的模块</span></span><br><span class="line">            yolo_block = self.add_sublayer(</span><br><span class="line">                <span class="string">"yolo_detecton_block_%d"</span> % (i),</span><br><span class="line">                YoloDetectionBlock(self.full_name(),</span><br><span class="line">                                   channel = <span class="number">512</span>//(<span class="number">2</span>**i),</span><br><span class="line">                                   is_test = <span class="keyword">not</span> self.is_train))</span><br><span class="line">            self.yolo_blocks.append(yolo_block)</span><br><span class="line"></span><br><span class="line">            num_filters = <span class="number">3</span> * (self.num_classes + <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 添加从ti生成pi的模块，这是一个Conv2D操作，输出通道数为3 * (num_classes + 5)</span></span><br><span class="line">            block_out = self.add_sublayer(</span><br><span class="line">                <span class="string">"block_out_%d"</span> % (i),</span><br><span class="line">                Conv2D(self.full_name(),</span><br><span class="line">                       num_filters=num_filters,</span><br><span class="line">                       filter_size=<span class="number">1</span>,</span><br><span class="line">                       stride=<span class="number">1</span>,</span><br><span class="line">                       padding=<span class="number">0</span>,</span><br><span class="line">                       act=<span class="literal">None</span>,</span><br><span class="line">                       param_attr=ParamAttr(</span><br><span class="line">                           initializer=fluid.initializer.Normal(<span class="number">0.</span>, <span class="number">0.02</span>)),</span><br><span class="line">                       bias_attr=ParamAttr(</span><br><span class="line">                           initializer=fluid.initializer.Constant(<span class="number">0.0</span>),</span><br><span class="line">                           regularizer=L2Decay(<span class="number">0.</span>))))</span><br><span class="line">            self.block_outputs.append(block_out)</span><br><span class="line">            <span class="keyword">if</span> i &lt; <span class="number">2</span>:</span><br><span class="line">                <span class="comment"># 对ri进行卷积</span></span><br><span class="line">                route = self.add_sublayer(<span class="string">"route2_%d"</span>%i,</span><br><span class="line">                                          ConvBNLayer(self.full_name(),</span><br><span class="line">                                                      ch_out=<span class="number">256</span>//(<span class="number">2</span>**i),</span><br><span class="line">                                                      filter_size=<span class="number">1</span>,</span><br><span class="line">                                                      stride=<span class="number">1</span>,</span><br><span class="line">                                                      padding=<span class="number">0</span>,</span><br><span class="line">                                                      is_test=(<span class="keyword">not</span> self.is_train)))</span><br><span class="line">                self.route_blocks_2.append(route)</span><br><span class="line">            <span class="comment"># 将ri放大以便跟c_&#123;i+1&#125;保持同样的尺寸</span></span><br><span class="line">            self.upsample = Upsample(self.full_name())</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, inputs)</span>:</span></span><br><span class="line">        outputs = []</span><br><span class="line">        blocks = self.block(inputs)</span><br><span class="line">        <span class="keyword">for</span> i, block <span class="keyword">in</span> enumerate(blocks):</span><br><span class="line">            <span class="keyword">if</span> i &gt; <span class="number">0</span>:</span><br><span class="line">                <span class="comment"># 将r_&#123;i-1&#125;经过卷积和上采样之后得到特征图，与这一级的ci进行拼接</span></span><br><span class="line">                block = fluid.layers.concat(input=[route, block], axis=<span class="number">1</span>)</span><br><span class="line">            <span class="comment"># 从ci生成ti和ri</span></span><br><span class="line">            route, tip = self.yolo_blocks[i](block)</span><br><span class="line">            <span class="comment"># 从ti生成pi</span></span><br><span class="line">            block_out = self.block_outputs[i](tip)</span><br><span class="line">            <span class="comment"># 将pi放入列表</span></span><br><span class="line">            outputs.append(block_out)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> i &lt; <span class="number">2</span>:</span><br><span class="line">                <span class="comment"># 对ri进行卷积调整通道数</span></span><br><span class="line">                route = self.route_blocks_2[i](route)</span><br><span class="line">                <span class="comment"># 对ri进行放大，使其尺寸和c_&#123;i+1&#125;保持一致</span></span><br><span class="line">                route = self.upsample(route)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> outputs</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_loss</span><span class="params">(self, outputs, gtbox, gtlabel, gtscore=None,</span></span></span><br><span class="line"><span class="function"><span class="params">                 anchors = [<span class="number">10</span>, <span class="number">13</span>, <span class="number">16</span>, <span class="number">30</span>, <span class="number">33</span>, <span class="number">23</span>, <span class="number">30</span>, <span class="number">61</span>, <span class="number">62</span>, <span class="number">45</span>, <span class="number">59</span>, <span class="number">119</span>, <span class="number">116</span>, <span class="number">90</span>, <span class="number">156</span>, <span class="number">198</span>, <span class="number">373</span>, <span class="number">326</span>],</span></span></span><br><span class="line"><span class="function"><span class="params">                 anchor_masks = [[<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>], [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>], [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>]],</span></span></span><br><span class="line"><span class="function"><span class="params">                 ignore_thresh=<span class="number">0.7</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                 use_label_smooth=False)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        使用fluid.layers.yolov3_loss，直接计算损失函数，过程更简洁，速度也更快</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.losses = []</span><br><span class="line">        downsample = <span class="number">32</span></span><br><span class="line">        <span class="keyword">for</span> i, out <span class="keyword">in</span> enumerate(outputs): <span class="comment"># 对三个层级分别求损失函数</span></span><br><span class="line">            anchor_mask_i = anchor_masks[i]</span><br><span class="line">            loss = fluid.layers.yolov3_loss(</span><br><span class="line">                    x=out,  <span class="comment"># out是P0, P1, P2中的一个</span></span><br><span class="line">                    gt_box=gtbox,  <span class="comment"># 真实框坐标</span></span><br><span class="line">                    gt_label=gtlabel,  <span class="comment"># 真实框类别</span></span><br><span class="line">                    gt_score=gtscore,  <span class="comment"># 真实框得分，使用mixup训练技巧时需要，不使用该技巧时直接设置为1，形状与gtlabel相同</span></span><br><span class="line">                    anchors=anchors,   <span class="comment"># 锚框尺寸，包含[w0, h0, w1, h1, ..., w8, h8]共9个锚框的尺寸</span></span><br><span class="line">                    anchor_mask=anchor_mask_i, <span class="comment"># 筛选锚框的mask，例如anchor_mask_i=[3, 4, 5]，将anchors中第3、4、5个锚框挑选出来给该层级使用</span></span><br><span class="line">                    class_num=self.num_classes, <span class="comment"># 分类类别数</span></span><br><span class="line">                    ignore_thresh=ignore_thresh, <span class="comment"># 当预测框与真实框IoU &gt; ignore_thresh，标注objectness = -1</span></span><br><span class="line">                    downsample_ratio=downsample, <span class="comment"># 特征图相对于原图缩小的倍数，例如P0是32， P1是16，P2是8</span></span><br><span class="line">                    use_label_smooth=<span class="literal">False</span>)      <span class="comment"># 使用label_smooth训练技巧时会用到，这里没用此技巧，直接设置为False</span></span><br><span class="line">            self.losses.append(fluid.layers.reduce_mean(loss))  <span class="comment">#reduce_mean对每张图片求和</span></span><br><span class="line">            downsample = downsample // <span class="number">2</span> <span class="comment"># 下一级特征图的缩放倍数会减半</span></span><br><span class="line">        <span class="keyword">return</span> sum(self.losses) <span class="comment"># 对每个层级求和</span></span><br></pre></td></tr></table></figure>

<h3 id="开启端到端训练"><a href="#开启端到端训练" class="headerlink" title="开启端到端训练"></a>开启端到端训练</h3><p>训练过程的流程如下图所示，输入图片经过特征提取得到三个层级的输出特征图P0(stride=32)、P1(stride=16)和P2(stride=8)，相应的分别使用不同大小的小方块区域去生成对应的锚框和预测框，并对这些锚框进行标注。</p>
<ul>
<li><p>P0层级特征图，对应着使用$32\times32$大小的小方块，在每个区域中心生成大小分别为$[116, 90]$, $[156, 198]$, $[373, 326]$的三种锚框。</p>
</li>
<li><p>P1层级特征图，对应着使用$16\times16$大小的小方块，在每个区域中心生成大小分别为$[30, 61]$, $[62, 45]$, $[59, 119]$的三种锚框。</p>
</li>
<li><p>P2层级特征图，对应着使用$8\times8$大小的小方块，在每个区域中心生成大小分别为$[10, 13]$, $[16, 30]$, $[33, 23]$的三种锚框。</p>
</li>
</ul>
<p>将三个层级的特征图与对应锚框之间的标签关联起来，并建立损失函数，总的损失函数等于三个层级的损失函数相加。通过极小化损失函数，可以开启端到端的训练过程。</p>
<p><br></br></p>
<center><img src="https://ai-studio-static-online.cdn.bcebos.com/d0bf0309b11944109b3b9d38280ffcf3e3921fe5a3714c3ebfbff64fc76f0dc7" width = "800"></center>
<center><br>图20：端到端训练流程 </br></center>
<br></br>

<p>训练过程的具体实现代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">############# 这段代码在本地机器上运行请慎重，容易造成死机#######################</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> paddle</span><br><span class="line"><span class="keyword">import</span> paddle.fluid <span class="keyword">as</span> fluid</span><br><span class="line"></span><br><span class="line">ANCHORS = [<span class="number">10</span>, <span class="number">13</span>, <span class="number">16</span>, <span class="number">30</span>, <span class="number">33</span>, <span class="number">23</span>, <span class="number">30</span>, <span class="number">61</span>, <span class="number">62</span>, <span class="number">45</span>, <span class="number">59</span>, <span class="number">119</span>, <span class="number">116</span>, <span class="number">90</span>, <span class="number">156</span>, <span class="number">198</span>, <span class="number">373</span>, <span class="number">326</span>]</span><br><span class="line"></span><br><span class="line">ANCHOR_MASKS = [[<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>], [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>], [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>]]</span><br><span class="line"></span><br><span class="line">IGNORE_THRESH = <span class="number">.7</span></span><br><span class="line">NUM_CLASSES = <span class="number">7</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_lr</span><span class="params">(base_lr = <span class="number">0.0001</span>, lr_decay = <span class="number">0.1</span>)</span>:</span></span><br><span class="line">    bd = [<span class="number">10000</span>, <span class="number">20000</span>]</span><br><span class="line">    lr = [base_lr, base_lr * lr_decay, base_lr * lr_decay * lr_decay]</span><br><span class="line">    learning_rate = fluid.layers.piecewise_decay(boundaries=bd, values=lr)</span><br><span class="line">    <span class="keyword">return</span> learning_rate</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line"></span><br><span class="line">    TRAINDIR = <span class="string">'/home/aistudio/work/insects/train'</span></span><br><span class="line">    TESTDIR = <span class="string">'/home/aistudio/work/insects/test'</span></span><br><span class="line">    VALIDDIR = <span class="string">'/home/aistudio/work/insects/val'</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> fluid.dygraph.guard():</span><br><span class="line">        model = YOLOv3(<span class="string">'yolov3'</span>, num_classes = NUM_CLASSES, is_train=<span class="literal">True</span>)  <span class="comment">#创建模型</span></span><br><span class="line">        learning_rate = get_lr()</span><br><span class="line">        opt = fluid.optimizer.Momentum(</span><br><span class="line">                     learning_rate=learning_rate,</span><br><span class="line">                     momentum=<span class="number">0.9</span>,</span><br><span class="line">                     regularization=fluid.regularizer.L2Decay(<span class="number">0.0005</span>))  <span class="comment">#创建优化器</span></span><br><span class="line"></span><br><span class="line">        train_loader = multithread_loader(TRAINDIR, batch_size= <span class="number">10</span>, mode=<span class="string">'train'</span>)  <span class="comment">#创建训练数据读取器</span></span><br><span class="line">        valid_loader = multithread_loader(VALIDDIR, batch_size= <span class="number">10</span>, mode=<span class="string">'valid'</span>)  <span class="comment">#创建验证数据读取器</span></span><br><span class="line"></span><br><span class="line">        MAX_EPOCH = <span class="number">200</span></span><br><span class="line">        <span class="keyword">for</span> epoch <span class="keyword">in</span> range(MAX_EPOCH):</span><br><span class="line">            <span class="keyword">for</span> i, data <span class="keyword">in</span> enumerate(train_loader()):</span><br><span class="line">                img, gt_boxes, gt_labels, img_scale = data</span><br><span class="line">                gt_scores = np.ones(gt_labels.shape).astype(<span class="string">'float32'</span>)</span><br><span class="line">                gt_scores = to_variable(gt_scores)</span><br><span class="line">                img = to_variable(img)</span><br><span class="line">                gt_boxes = to_variable(gt_boxes)</span><br><span class="line">                gt_labels = to_variable(gt_labels)</span><br><span class="line">                outputs = model(img)  <span class="comment">#前向传播，输出[P0, P1, P2]</span></span><br><span class="line">                loss = model.get_loss(outputs, gt_boxes, gt_labels, gtscore=gt_scores,</span><br><span class="line">                                      anchors = ANCHORS,</span><br><span class="line">                                      anchor_masks = ANCHOR_MASKS,</span><br><span class="line">                                      ignore_thresh=IGNORE_THRESH,</span><br><span class="line">                                      use_label_smooth=<span class="literal">False</span>)        <span class="comment"># 计算损失函数</span></span><br><span class="line"></span><br><span class="line">                loss.backward()     <span class="comment"># 反向传播计算梯度</span></span><br><span class="line">                opt.minimize(loss)  <span class="comment"># 更新参数</span></span><br><span class="line">                model.clear_gradients()</span><br><span class="line">                <span class="keyword">if</span> i % <span class="number">1</span> == <span class="number">0</span>:</span><br><span class="line">                    timestring = time.strftime(<span class="string">"%Y-%m-%d %H:%M:%S"</span>,time.localtime(time.time()))</span><br><span class="line">                    print(<span class="string">'&#123;&#125;[TRAIN]epoch &#123;&#125;, iter &#123;&#125;, output loss: &#123;&#125;'</span>.format(timestring, epoch, i, loss.numpy()))</span><br><span class="line"></span><br><span class="line">            <span class="comment"># save params of model</span></span><br><span class="line">            <span class="keyword">if</span> (epoch % <span class="number">5</span> == <span class="number">0</span>) <span class="keyword">or</span> (epoch == MAX_EPOCH <span class="number">-1</span>):</span><br><span class="line">                fluid.save_dygraph(model.state_dict(), <span class="string">'yolo_epoch&#123;&#125;'</span>.format(epoch))</span><br><span class="line">                </span><br><span class="line">            <span class="comment"># 每个epoch结束之后在验证集上进行测试</span></span><br><span class="line">            model.eval()</span><br><span class="line">            <span class="keyword">for</span> i, data <span class="keyword">in</span> enumerate(valid_loader()):</span><br><span class="line">                img, gt_boxes, gt_labels, img_scale = data</span><br><span class="line">                gt_scores = np.ones(gt_labels.shape).astype(<span class="string">'float32'</span>)</span><br><span class="line">                gt_scores = to_variable(gt_scores)</span><br><span class="line">                img = to_variable(img)</span><br><span class="line">                gt_boxes = to_variable(gt_boxes)</span><br><span class="line">                gt_labels = to_variable(gt_labels)</span><br><span class="line">                outputs = model(img)</span><br><span class="line">                loss = model.get_loss(outputs, gt_boxes, gt_labels, gtscore=gt_scores,</span><br><span class="line">                                      anchors = ANCHORS,</span><br><span class="line">                                      anchor_masks = ANCHOR_MASKS,</span><br><span class="line">                                      ignore_thresh=IGNORE_THRESH,</span><br><span class="line">                                      use_label_smooth=<span class="literal">False</span>)</span><br><span class="line">                <span class="keyword">if</span> i % <span class="number">1</span> == <span class="number">0</span>:</span><br><span class="line">                    timestring = time.strftime(<span class="string">"%Y-%m-%d %H:%M:%S"</span>,time.localtime(time.time()))</span><br><span class="line">                    print(<span class="string">'&#123;&#125;[VALID]epoch &#123;&#125;, iter &#123;&#125;, output loss: &#123;&#125;'</span>.format(timestring, epoch, i, loss.numpy()))</span><br><span class="line">            model.train()</span><br></pre></td></tr></table></figure>

<h2 id="预测"><a href="#预测" class="headerlink" title="预测"></a>预测</h2><p>预测过程流程 <strong>图21</strong> 如下所示：</p>
<p><br></br></p>
<center><img src="https://ai-studio-static-online.cdn.bcebos.com/14ebf91897ea4d5787dfaaefe9e3030f0e6f704eec134440b4c495f74ab49003" width = "600"></center>
<center><br>图21：端到端训练流程 </br></center>
<br></br>

<p>预测过程可以分为两步：</p>
<ol>
<li>通过网络输出计算出预测框位置和所属类别的得分。 </li>
<li>使用非极大值抑制来消除重叠较大的预测框。</li>
</ol>
<p>对于第1步，前面我们已经讲过如何通过网络输出值计算pred_objectness_probability, pred_boxes以及pred_classification_probability，这里推荐大家直接使用fluid.layers.yolo_box，其使用方法是：</p>
<ul>
<li><p>fluid.layers.yolo_box(x, img_size, anchors, class_num, conf_thresh, downsample_ratio, name=None)</p>
<ul>
<li>x，网络输出特征图，例如上面提到的P0或者P1、P2</li>
<li>img_size，输入图片尺寸</li>
<li>anchors，使用到的anchor的尺寸，如[10, 13, 16, 30, 33, 23, 30, 61, 62, 45, 59, 119, 116, 90, 156, 198, 373, 326]</li>
<li>anchor_mask: 每个层级上使用的anchor的掩码，[[6, 7, 8], [3, 4, 5], [0, 1, 2]]</li>
<li>class_num，物体类别数目</li>
<li>conf_thresh, 置信度阈值，得分低于该阈值的预测框位置数值不用计算直接设置为0.0</li>
<li>downsample_ratio, 特征图的下采样比例，例如P0是32，P1是16，P2是8</li>
<li>name=None，名字，例如’yolo_box’</li>
</ul>
</li>
<li><p>返回值包括两项，boxes和scores，其中boxes是所有预测框的坐标值，scores是所有预测框的得分。</p>
</li>
</ul>
<p>预测框得分的定义是所属类别的概率乘以其预测框是否包含目标物体的objectness概率，即</p>
<p>$$score = P_{obj} \cdot P_{classification}$$</p>
<p>在上面定义的类YOLO-V3下面添加函数，get_pred，通过调用fluid.layers.yolo_box获得P0、P1、P2三个层级的特征图对应的预测框和得分，并将他们拼接在一块，即可得到所有的预测框及其属于各个类别的得分。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">YOLOv3</span><span class="params">(fluid.dygraph.Layer)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,name_scope, num_classes=<span class="number">7</span>, is_train=True)</span>:</span></span><br><span class="line">        super(YOLOv3,self).__init__(name_scope)</span><br><span class="line"></span><br><span class="line">        self.is_train = is_train</span><br><span class="line">        self.num_classes = num_classes</span><br><span class="line">        <span class="comment"># 提取图像特征的骨干代码</span></span><br><span class="line">        self.block = DarkNet53_conv_body(self.full_name(),</span><br><span class="line">                                         is_test = <span class="keyword">not</span> self.is_train)</span><br><span class="line">        self.block_outputs = []</span><br><span class="line">        self.yolo_blocks = []</span><br><span class="line">        self.route_blocks_2 = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">            <span class="comment"># 添加从ci生成ri和ti的模块</span></span><br><span class="line">            yolo_block = self.add_sublayer(</span><br><span class="line">                <span class="string">"yolo_detecton_block_%d"</span> % (i),</span><br><span class="line">                YoloDetectionBlock(self.full_name(),</span><br><span class="line">                                   channel = <span class="number">512</span>//(<span class="number">2</span>**i),</span><br><span class="line">                                   is_test = <span class="keyword">not</span> self.is_train))</span><br><span class="line">            self.yolo_blocks.append(yolo_block)</span><br><span class="line"></span><br><span class="line">            num_filters = <span class="number">3</span> * (self.num_classes + <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 添加从ti生成pi的模块，这是一个Conv2D操作，输出通道数为3 * (num_classes + 5)</span></span><br><span class="line">            block_out = self.add_sublayer(</span><br><span class="line">                <span class="string">"block_out_%d"</span> % (i),</span><br><span class="line">                Conv2D(self.full_name(),</span><br><span class="line">                       num_filters=num_filters,</span><br><span class="line">                       filter_size=<span class="number">1</span>,</span><br><span class="line">                       stride=<span class="number">1</span>,</span><br><span class="line">                       padding=<span class="number">0</span>,</span><br><span class="line">                       act=<span class="literal">None</span>,</span><br><span class="line">                       param_attr=ParamAttr(</span><br><span class="line">                           initializer=fluid.initializer.Normal(<span class="number">0.</span>, <span class="number">0.02</span>)),</span><br><span class="line">                       bias_attr=ParamAttr(</span><br><span class="line">                           initializer=fluid.initializer.Constant(<span class="number">0.0</span>),</span><br><span class="line">                           regularizer=L2Decay(<span class="number">0.</span>))))</span><br><span class="line">            self.block_outputs.append(block_out)</span><br><span class="line">            <span class="keyword">if</span> i &lt; <span class="number">2</span>:</span><br><span class="line">                <span class="comment"># 对ri进行卷积</span></span><br><span class="line">                route = self.add_sublayer(<span class="string">"route2_%d"</span>%i,</span><br><span class="line">                                          ConvBNLayer(self.full_name(),</span><br><span class="line">                                                      ch_out=<span class="number">256</span>//(<span class="number">2</span>**i),</span><br><span class="line">                                                      filter_size=<span class="number">1</span>,</span><br><span class="line">                                                      stride=<span class="number">1</span>,</span><br><span class="line">                                                      padding=<span class="number">0</span>,</span><br><span class="line">                                                      is_test=(<span class="keyword">not</span> self.is_train)))</span><br><span class="line">                self.route_blocks_2.append(route)</span><br><span class="line">            <span class="comment"># 将ri放大以便跟c_&#123;i+1&#125;保持同样的尺寸</span></span><br><span class="line">            self.upsample = Upsample(self.full_name())</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, inputs)</span>:</span></span><br><span class="line">        outputs = []</span><br><span class="line">        blocks = self.block(inputs)</span><br><span class="line">        <span class="keyword">for</span> i, block <span class="keyword">in</span> enumerate(blocks):</span><br><span class="line">            <span class="keyword">if</span> i &gt; <span class="number">0</span>:</span><br><span class="line">                <span class="comment"># 将r_&#123;i-1&#125;经过卷积和上采样之后得到特征图，与这一级的ci进行拼接</span></span><br><span class="line">                block = fluid.layers.concat(input=[route, block], axis=<span class="number">1</span>)</span><br><span class="line">            <span class="comment"># 从ci生成ti和ri</span></span><br><span class="line">            route, tip = self.yolo_blocks[i](block)</span><br><span class="line">            <span class="comment"># 从ti生成pi</span></span><br><span class="line">            block_out = self.block_outputs[i](tip)</span><br><span class="line">            <span class="comment"># 将pi放入列表</span></span><br><span class="line">            outputs.append(block_out)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> i &lt; <span class="number">2</span>:</span><br><span class="line">                <span class="comment"># 对ri进行卷积调整通道数</span></span><br><span class="line">                route = self.route_blocks_2[i](route)</span><br><span class="line">                <span class="comment"># 对ri进行放大，使其尺寸和c_&#123;i+1&#125;保持一致</span></span><br><span class="line">                route = self.upsample(route)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> outputs</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_loss</span><span class="params">(self, outputs, gtbox, gtlabel, gtscore=None,</span></span></span><br><span class="line"><span class="function"><span class="params">                 anchors = [<span class="number">10</span>, <span class="number">13</span>, <span class="number">16</span>, <span class="number">30</span>, <span class="number">33</span>, <span class="number">23</span>, <span class="number">30</span>, <span class="number">61</span>, <span class="number">62</span>, <span class="number">45</span>, <span class="number">59</span>, <span class="number">119</span>, <span class="number">116</span>, <span class="number">90</span>, <span class="number">156</span>, <span class="number">198</span>, <span class="number">373</span>, <span class="number">326</span>],</span></span></span><br><span class="line"><span class="function"><span class="params">                 anchor_masks = [[<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>], [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>], [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>]],</span></span></span><br><span class="line"><span class="function"><span class="params">                 ignore_thresh=<span class="number">0.7</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                 use_label_smooth=False)</span>:</span></span><br><span class="line"></span><br><span class="line">        self.losses = []</span><br><span class="line">        downsample = <span class="number">32</span></span><br><span class="line">        <span class="keyword">for</span> i, out <span class="keyword">in</span> enumerate(outputs):</span><br><span class="line">            anchor_mask_i = anchor_masks[i]</span><br><span class="line">            loss = fluid.layers.yolov3_loss(</span><br><span class="line">                    x=out,</span><br><span class="line">                    gt_box=gtbox,</span><br><span class="line">                    gt_label=gtlabel,</span><br><span class="line">                    gt_score=gtscore,</span><br><span class="line">                    anchors=anchors,</span><br><span class="line">                    anchor_mask=anchor_mask_i,</span><br><span class="line">                    class_num=self.num_classes,</span><br><span class="line">                    ignore_thresh=ignore_thresh,</span><br><span class="line">                    downsample_ratio=downsample,</span><br><span class="line">                    use_label_smooth=<span class="literal">False</span>)</span><br><span class="line">            self.losses.append(fluid.layers.reduce_mean(loss))</span><br><span class="line">            downsample = downsample // <span class="number">2</span></span><br><span class="line">        <span class="keyword">return</span> sum(self.losses)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_pred</span><span class="params">(self,</span></span></span><br><span class="line"><span class="function"><span class="params">                 outputs,</span></span></span><br><span class="line"><span class="function"><span class="params">                 im_shape=None,</span></span></span><br><span class="line"><span class="function"><span class="params">                 anchors = [<span class="number">10</span>, <span class="number">13</span>, <span class="number">16</span>, <span class="number">30</span>, <span class="number">33</span>, <span class="number">23</span>, <span class="number">30</span>, <span class="number">61</span>, <span class="number">62</span>, <span class="number">45</span>, <span class="number">59</span>, <span class="number">119</span>, <span class="number">116</span>, <span class="number">90</span>, <span class="number">156</span>, <span class="number">198</span>, <span class="number">373</span>, <span class="number">326</span>],</span></span></span><br><span class="line"><span class="function"><span class="params">                 anchor_masks = [[<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>], [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>], [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>]],</span></span></span><br><span class="line"><span class="function"><span class="params">                 valid_thresh = <span class="number">0.01</span>)</span>:</span></span><br><span class="line">        downsample = <span class="number">32</span></span><br><span class="line">        total_boxes = []</span><br><span class="line">        total_scores = []</span><br><span class="line">        <span class="keyword">for</span> i, out <span class="keyword">in</span> enumerate(outputs):</span><br><span class="line">            anchor_mask = anchor_masks[i]</span><br><span class="line">            anchors_this_level = []</span><br><span class="line">            <span class="keyword">for</span> m <span class="keyword">in</span> anchor_mask:</span><br><span class="line">                anchors_this_level.append(anchors[<span class="number">2</span> * m])</span><br><span class="line">                anchors_this_level.append(anchors[<span class="number">2</span> * m + <span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">            boxes, scores = fluid.layers.yolo_box(</span><br><span class="line">                   x=out,</span><br><span class="line">                   img_size=im_shape,</span><br><span class="line">                   anchors=anchors_this_level,</span><br><span class="line">                   class_num=self.num_classes,</span><br><span class="line">                   conf_thresh=valid_thresh,</span><br><span class="line">                   downsample_ratio=downsample,</span><br><span class="line">                   name=<span class="string">"yolo_box"</span> + str(i))</span><br><span class="line">            total_boxes.append(boxes)</span><br><span class="line">            total_scores.append(</span><br><span class="line">                        fluid.layers.transpose(</span><br><span class="line">                        scores, perm=[<span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>]))</span><br><span class="line">            downsample = downsample // <span class="number">2</span></span><br><span class="line"></span><br><span class="line">        yolo_boxes = fluid.layers.concat(total_boxes, axis=<span class="number">1</span>)</span><br><span class="line">        yolo_scores = fluid.layers.concat(total_scores, axis=<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> yolo_boxes, yolo_scores</span><br></pre></td></tr></table></figure>

<p>第1步的计算结果会在每个小方块区域都会产生多个预测框，输出预测框中会有很多重合度比较大，需要消除重叠较大的冗余预测框。</p>
<p>下面示例代码中的预测框是使用模型对图片预测之后输出的，这里一共选出了11个预测框，在图上画出预测框如下所示。在每个人像周围，都出现了多个预测框，需要消除冗余的预测框以得到最终的预测结果。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 画图展示目标物体边界框</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> matplotlib.patches <span class="keyword">as</span> patches</span><br><span class="line"><span class="keyword">from</span> matplotlib.image <span class="keyword">import</span> imread</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义画矩形框的程序    </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">draw_rectangle</span><span class="params">(currentAxis, bbox, edgecolor = <span class="string">'k'</span>, facecolor = <span class="string">'y'</span>, fill=False, linestyle=<span class="string">'-'</span>)</span>:</span></span><br><span class="line">    <span class="comment"># currentAxis，坐标轴，通过plt.gca()获取</span></span><br><span class="line">    <span class="comment"># bbox，边界框，包含四个数值的list， [x1, y1, x2, y2]</span></span><br><span class="line">    <span class="comment"># edgecolor，边框线条颜色</span></span><br><span class="line">    <span class="comment"># facecolor，填充颜色</span></span><br><span class="line">    <span class="comment"># fill, 是否填充</span></span><br><span class="line">    <span class="comment"># linestype，边框线型</span></span><br><span class="line">    <span class="comment"># patches.Rectangle需要传入左上角坐标、矩形区域的宽度、高度等参数</span></span><br><span class="line">    rect=patches.Rectangle((bbox[<span class="number">0</span>], bbox[<span class="number">1</span>]), bbox[<span class="number">2</span>]-bbox[<span class="number">0</span>]+<span class="number">1</span>, bbox[<span class="number">3</span>]-bbox[<span class="number">1</span>]+<span class="number">1</span>, linewidth=<span class="number">1</span>,</span><br><span class="line">                           edgecolor=edgecolor,facecolor=facecolor,fill=fill, linestyle=linestyle)</span><br><span class="line">    currentAxis.add_patch(rect)</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">plt.figure(figsize=(<span class="number">10</span>, <span class="number">10</span>))</span><br><span class="line"></span><br><span class="line">filename = <span class="string">'/home/aistudio/work/images/section3/000000086956.jpg'</span></span><br><span class="line">im = imread(filename)</span><br><span class="line">plt.imshow(im)</span><br><span class="line"></span><br><span class="line">currentAxis=plt.gca()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 预测框位置</span></span><br><span class="line">boxes = np.array([[<span class="number">4.21716537e+01</span>, <span class="number">1.28230896e+02</span>, <span class="number">2.26547668e+02</span>, <span class="number">6.00434631e+02</span>],</span><br><span class="line">       [<span class="number">3.18562988e+02</span>, <span class="number">1.23168472e+02</span>, <span class="number">4.79000000e+02</span>, <span class="number">6.05688416e+02</span>],</span><br><span class="line">       [<span class="number">2.62704697e+01</span>, <span class="number">1.39430557e+02</span>, <span class="number">2.20587097e+02</span>, <span class="number">6.38959656e+02</span>],</span><br><span class="line">       [<span class="number">4.24965363e+01</span>, <span class="number">1.42706665e+02</span>, <span class="number">2.25955185e+02</span>, <span class="number">6.35671204e+02</span>],</span><br><span class="line">       [<span class="number">2.37462646e+02</span>, <span class="number">1.35731537e+02</span>, <span class="number">4.79000000e+02</span>, <span class="number">6.31451294e+02</span>],</span><br><span class="line">       [<span class="number">3.19390472e+02</span>, <span class="number">1.29295090e+02</span>, <span class="number">4.79000000e+02</span>, <span class="number">6.33003845e+02</span>],</span><br><span class="line">       [<span class="number">3.28933838e+02</span>, <span class="number">1.22736115e+02</span>, <span class="number">4.79000000e+02</span>, <span class="number">6.39000000e+02</span>],</span><br><span class="line">       [<span class="number">4.44292603e+01</span>, <span class="number">1.70438187e+02</span>, <span class="number">2.26841858e+02</span>, <span class="number">6.39000000e+02</span>],</span><br><span class="line">       [<span class="number">2.17988785e+02</span>, <span class="number">3.02472412e+02</span>, <span class="number">4.06062927e+02</span>, <span class="number">6.29106628e+02</span>],</span><br><span class="line">       [<span class="number">2.00241089e+02</span>, <span class="number">3.23755096e+02</span>, <span class="number">3.96929321e+02</span>, <span class="number">6.36386108e+02</span>],</span><br><span class="line">       [<span class="number">2.14310303e+02</span>, <span class="number">3.23443665e+02</span>, <span class="number">4.06732849e+02</span>, <span class="number">6.35775269e+02</span>]])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 预测框得分</span></span><br><span class="line">scores = np.array([<span class="number">0.5247661</span> , <span class="number">0.51759845</span>, <span class="number">0.86075854</span>, <span class="number">0.9910175</span> , <span class="number">0.39170712</span>,</span><br><span class="line">       <span class="number">0.9297706</span> , <span class="number">0.5115228</span> , <span class="number">0.270992</span>  , <span class="number">0.19087596</span>, <span class="number">0.64201415</span>, <span class="number">0.879036</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 画出所有预测框</span></span><br><span class="line"><span class="keyword">for</span> box <span class="keyword">in</span> boxes:</span><br><span class="line">    draw_rectangle(currentAxis, box)</span><br></pre></td></tr></table></figure>

<p><img src="output_129_0.png" alt="png"></p>
<p>这里使用非极大值抑制（non-maximum suppression, nms）来消除冗余框，其基本思想是，如果有多个预测框都对应同一个物体，则只选出得分最高的那个预测框，剩下的预测框被丢弃掉。那么如何判断两个预测框对应的是同一个物体呢，标准该怎么设置？如果两个预测框的类别一样，而且他们的位置重合度比较大，则可以认为他们是在预测同一个目标。非极大值抑制的做法是，选出某个类别得分最高的预测框，然后看哪些预测框跟它的IoU大于阈值，就把这些预测框给丢弃掉。这里IoU的阈值是超参数，需要提前设置，YOLO-V3模型里面设置的是0.5。</p>
<p>比如在上面的程序中，boxes里面一共对应11个预测框，scores给出了它们预测”人”这一类别的得分。</p>
<ul>
<li>Step0 创建选中列表，keep_list = []</li>
<li>Step1 对得分进行排序，remain_list = [ 3,  5, 10,  2,  9,  0,  1,  6,  4,  7,  8]， </li>
<li>Step2 选出boxes[3]，此时keep_list为空，不需要计算IoU，直接将其放入keep_list，keep_list = [3]， remain_list=[5, 10,  2,  9,  0,  1,  6,  4,  7,  8]</li>
<li>Step3 选出boxes[5]，此时keep_list中已经存在boxes[3]，计算出IoU(boxes[3], boxes[5]) = 0.0，显然小于阈值，则keep_list=[3, 5], remain_list = [10,  2,  9,  0,  1,  6,  4,  7,  8]</li>
<li>Step4 选出boxes[10]，此时keep_list=[3, 5]，计算IoU(boxes[3], boxes[10])=0.0268，IoU(boxes[5], boxes[10])=0.0268 = 0.24，都小于阈值，则keep_list = [3, 5, 10]，remain_list=[2,  9,  0,  1,  6,  4,  7,  8]</li>
<li>Step5 选出boxes[2]，此时keep_list = [3, 5, 10]，计算IoU(boxes[3], boxes[2]) = 0.88，超过了阈值，直接将boxes[2]丢弃，keep_list=[3, 5, 10]，remain_list=[9,  0,  1,  6,  4,  7,  8]</li>
<li>Step6 选出boxes[9]，此时keep_list = [3, 5, 10]，计算IoU(boxes[3], boxes[9]) = 0.0577，IoU(boxes[5], boxes[9]) = 0.205，IoU(boxes[10], boxes[9]) = 0.88，超过了阈值，将boxes[9]丢弃掉。keep_list=[3, 5, 10]，remain_list=[0,  1,  6,  4,  7,  8]</li>
<li>Step7 重复上述Step6直到remain_list为空</li>
</ul>
<p>最终得到keep_list=[3, 5, 10]，也就是预测框3、5、10被最终挑选出来了，如下图所示</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 画图展示目标物体边界框</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> matplotlib.patches <span class="keyword">as</span> patches</span><br><span class="line"><span class="keyword">from</span> matplotlib.image <span class="keyword">import</span> imread</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义画矩形框的程序    </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">draw_rectangle</span><span class="params">(currentAxis, bbox, edgecolor = <span class="string">'k'</span>, facecolor = <span class="string">'y'</span>, fill=False, linestyle=<span class="string">'-'</span>)</span>:</span></span><br><span class="line">    <span class="comment"># currentAxis，坐标轴，通过plt.gca()获取</span></span><br><span class="line">    <span class="comment"># bbox，边界框，包含四个数值的list， [x1, y1, x2, y2]</span></span><br><span class="line">    <span class="comment"># edgecolor，边框线条颜色</span></span><br><span class="line">    <span class="comment"># facecolor，填充颜色</span></span><br><span class="line">    <span class="comment"># fill, 是否填充</span></span><br><span class="line">    <span class="comment"># linestype，边框线型</span></span><br><span class="line">    <span class="comment"># patches.Rectangle需要传入左上角坐标、矩形区域的宽度、高度等参数</span></span><br><span class="line">    rect=patches.Rectangle((bbox[<span class="number">0</span>], bbox[<span class="number">1</span>]), bbox[<span class="number">2</span>]-bbox[<span class="number">0</span>]+<span class="number">1</span>, bbox[<span class="number">3</span>]-bbox[<span class="number">1</span>]+<span class="number">1</span>, linewidth=<span class="number">1</span>,</span><br><span class="line">                           edgecolor=edgecolor,facecolor=facecolor,fill=fill, linestyle=linestyle)</span><br><span class="line">    currentAxis.add_patch(rect)</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">plt.figure(figsize=(<span class="number">10</span>, <span class="number">10</span>))</span><br><span class="line"></span><br><span class="line">filename = <span class="string">'/home/aistudio/work/images/section3/000000086956.jpg'</span></span><br><span class="line">im = imread(filename)</span><br><span class="line">plt.imshow(im)</span><br><span class="line"></span><br><span class="line">currentAxis=plt.gca()</span><br><span class="line"></span><br><span class="line">boxes = np.array([[<span class="number">4.21716537e+01</span>, <span class="number">1.28230896e+02</span>, <span class="number">2.26547668e+02</span>, <span class="number">6.00434631e+02</span>],</span><br><span class="line">       [<span class="number">3.18562988e+02</span>, <span class="number">1.23168472e+02</span>, <span class="number">4.79000000e+02</span>, <span class="number">6.05688416e+02</span>],</span><br><span class="line">       [<span class="number">2.62704697e+01</span>, <span class="number">1.39430557e+02</span>, <span class="number">2.20587097e+02</span>, <span class="number">6.38959656e+02</span>],</span><br><span class="line">       [<span class="number">4.24965363e+01</span>, <span class="number">1.42706665e+02</span>, <span class="number">2.25955185e+02</span>, <span class="number">6.35671204e+02</span>],</span><br><span class="line">       [<span class="number">2.37462646e+02</span>, <span class="number">1.35731537e+02</span>, <span class="number">4.79000000e+02</span>, <span class="number">6.31451294e+02</span>],</span><br><span class="line">       [<span class="number">3.19390472e+02</span>, <span class="number">1.29295090e+02</span>, <span class="number">4.79000000e+02</span>, <span class="number">6.33003845e+02</span>],</span><br><span class="line">       [<span class="number">3.28933838e+02</span>, <span class="number">1.22736115e+02</span>, <span class="number">4.79000000e+02</span>, <span class="number">6.39000000e+02</span>],</span><br><span class="line">       [<span class="number">4.44292603e+01</span>, <span class="number">1.70438187e+02</span>, <span class="number">2.26841858e+02</span>, <span class="number">6.39000000e+02</span>],</span><br><span class="line">       [<span class="number">2.17988785e+02</span>, <span class="number">3.02472412e+02</span>, <span class="number">4.06062927e+02</span>, <span class="number">6.29106628e+02</span>],</span><br><span class="line">       [<span class="number">2.00241089e+02</span>, <span class="number">3.23755096e+02</span>, <span class="number">3.96929321e+02</span>, <span class="number">6.36386108e+02</span>],</span><br><span class="line">       [<span class="number">2.14310303e+02</span>, <span class="number">3.23443665e+02</span>, <span class="number">4.06732849e+02</span>, <span class="number">6.35775269e+02</span>]])</span><br><span class="line"> </span><br><span class="line">scores = np.array([<span class="number">0.5247661</span> , <span class="number">0.51759845</span>, <span class="number">0.86075854</span>, <span class="number">0.9910175</span> , <span class="number">0.39170712</span>,</span><br><span class="line">       <span class="number">0.9297706</span> , <span class="number">0.5115228</span> , <span class="number">0.270992</span>  , <span class="number">0.19087596</span>, <span class="number">0.64201415</span>, <span class="number">0.879036</span>])</span><br><span class="line"></span><br><span class="line">left_ind = np.where((boxes[:, <span class="number">0</span>]&lt;<span class="number">60</span>) * (boxes[:, <span class="number">0</span>]&gt;<span class="number">20</span>))</span><br><span class="line">left_boxes = boxes[left_ind]</span><br><span class="line">left_scores = scores[left_ind]</span><br><span class="line"></span><br><span class="line">colors = [<span class="string">'r'</span>, <span class="string">'g'</span>, <span class="string">'b'</span>, <span class="string">'k'</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 画出最终保留的预测框</span></span><br><span class="line">inds = [<span class="number">3</span>, <span class="number">5</span>, <span class="number">10</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">    box = boxes[inds[i]]</span><br><span class="line">    draw_rectangle(currentAxis, box, edgecolor=colors[i])</span><br></pre></td></tr></table></figure>

<p><img src="output_131_0.png" alt="png"></p>
<p>非极大值抑制的具体实现代码如下面nms函数的定义，需要说明的是数据集中含有多个类别的物体，所以这里需要做多分类非极大值抑制，其实现原理与非极大值抑制相同，区别在于需要对每个类别都做非极大值抑制，实现代码如下面的multiclass_nms所示。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 非极大值抑制</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">nms</span><span class="params">(bboxes, scores, score_thresh, nms_thresh, pre_nms_topk, i=<span class="number">0</span>, c=<span class="number">0</span>)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    nms</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    inds = np.argsort(scores)</span><br><span class="line">    inds = inds[::<span class="number">-1</span>]</span><br><span class="line">    keep_inds = []</span><br><span class="line">    <span class="keyword">while</span>(len(inds) &gt; <span class="number">0</span>):</span><br><span class="line">        cur_ind = inds[<span class="number">0</span>]</span><br><span class="line">        cur_score = scores[cur_ind]</span><br><span class="line">        <span class="comment"># if score of the box is less than score_thresh, just drop it</span></span><br><span class="line">        <span class="keyword">if</span> cur_score &lt; score_thresh:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        keep = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">for</span> ind <span class="keyword">in</span> keep_inds:</span><br><span class="line">            current_box = bboxes[cur_ind]</span><br><span class="line">            remain_box = bboxes[ind]</span><br><span class="line">            iou = box_iou_xyxy(current_box, remain_box)</span><br><span class="line">            <span class="keyword">if</span> iou &gt; nms_thresh:</span><br><span class="line">                keep = <span class="literal">False</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> i == <span class="number">0</span> <span class="keyword">and</span> c == <span class="number">4</span> <span class="keyword">and</span> cur_ind == <span class="number">951</span>:</span><br><span class="line">            print(<span class="string">'suppressed, '</span>, keep, i, c, cur_ind, ind, iou)</span><br><span class="line">        <span class="keyword">if</span> keep:</span><br><span class="line">            keep_inds.append(cur_ind)</span><br><span class="line">        inds = inds[<span class="number">1</span>:]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> np.array(keep_inds)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 多分类非极大值抑制</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">multiclass_nms</span><span class="params">(bboxes, scores, score_thresh=<span class="number">0.01</span>, nms_thresh=<span class="number">0.45</span>, pre_nms_topk=<span class="number">1000</span>, pos_nms_topk=<span class="number">100</span>)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    This is for multiclass_nms</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    batch_size = bboxes.shape[<span class="number">0</span>]</span><br><span class="line">    class_num = scores.shape[<span class="number">1</span>]</span><br><span class="line">    rets = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(batch_size):</span><br><span class="line">        bboxes_i = bboxes[i]</span><br><span class="line">        scores_i = scores[i]</span><br><span class="line">        ret = []</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> range(class_num):</span><br><span class="line">            scores_i_c = scores_i[c]</span><br><span class="line">            keep_inds = nms(bboxes_i, scores_i_c, score_thresh, nms_thresh, pre_nms_topk, i=i, c=c)</span><br><span class="line">            <span class="keyword">if</span> len(keep_inds) &lt; <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            keep_bboxes = bboxes_i[keep_inds]</span><br><span class="line">            keep_scores = scores_i_c[keep_inds]</span><br><span class="line">            keep_results = np.zeros([keep_scores.shape[<span class="number">0</span>], <span class="number">6</span>])</span><br><span class="line">            keep_results[:, <span class="number">0</span>] = c</span><br><span class="line">            keep_results[:, <span class="number">1</span>] = keep_scores[:]</span><br><span class="line">            keep_results[:, <span class="number">2</span>:<span class="number">6</span>] = keep_bboxes[:, :]</span><br><span class="line">            ret.append(keep_results)</span><br><span class="line">        <span class="keyword">if</span> len(ret) &lt; <span class="number">1</span>:</span><br><span class="line">            rets.append(ret)</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        ret_i = np.concatenate(ret, axis=<span class="number">0</span>)</span><br><span class="line">        scores_i = ret_i[:, <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">if</span> len(scores_i) &gt; pos_nms_topk:</span><br><span class="line">            inds = np.argsort(scores_i)[::<span class="number">-1</span>]</span><br><span class="line">            inds = inds[:pos_nms_topk]</span><br><span class="line">            ret_i = ret_i[inds]</span><br><span class="line"></span><br><span class="line">        rets.append(ret_i)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> rets</span><br></pre></td></tr></table></figure>

<p>下面是完整的测试程序，在测试数据集上的输出结果将会被保存在pred_results.json文件中。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line">ANCHORS = [<span class="number">10</span>, <span class="number">13</span>, <span class="number">16</span>, <span class="number">30</span>, <span class="number">33</span>, <span class="number">23</span>, <span class="number">30</span>, <span class="number">61</span>, <span class="number">62</span>, <span class="number">45</span>, <span class="number">59</span>, <span class="number">119</span>, <span class="number">116</span>, <span class="number">90</span>, <span class="number">156</span>, <span class="number">198</span>, <span class="number">373</span>, <span class="number">326</span>]</span><br><span class="line">ANCHOR_MASKS = [[<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>], [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>], [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>]]</span><br><span class="line">VALID_THRESH = <span class="number">0.01</span></span><br><span class="line">NMS_TOPK = <span class="number">400</span></span><br><span class="line">NMS_POSK = <span class="number">100</span></span><br><span class="line">NMS_THRESH = <span class="number">0.45</span></span><br><span class="line"></span><br><span class="line">NUM_CLASSES = <span class="number">7</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    TRAINDIR = <span class="string">'/home/aistudio/work/insects/train/images'</span></span><br><span class="line">    TESTDIR = <span class="string">'/home/aistudio/work/insects/test/images'</span></span><br><span class="line">    VALIDDIR = <span class="string">'/home/aistudio/work/insects/val'</span></span><br><span class="line">    <span class="keyword">with</span> fluid.dygraph.guard():</span><br><span class="line">        model = YOLOv3(<span class="string">'yolov3'</span>, num_classes=NUM_CLASSES, is_train=<span class="literal">False</span>)</span><br><span class="line">        params_file_path = <span class="string">'/home/aistudio/work/yolo_epoch50'</span></span><br><span class="line">        model_state_dict, _ = fluid.load_dygraph(params_file_path)</span><br><span class="line">        model.load_dict(model_state_dict)</span><br><span class="line">        model.eval()</span><br><span class="line"></span><br><span class="line">        total_results = []</span><br><span class="line">        test_loader = test_data_loader(TESTDIR, batch_size= <span class="number">1</span>, mode=<span class="string">'test'</span>)</span><br><span class="line">        <span class="keyword">for</span> i, data <span class="keyword">in</span> enumerate(test_loader()):</span><br><span class="line">            img_name, img_data, img_scale_data = data</span><br><span class="line">            img = to_variable(img_data)</span><br><span class="line">            img_scale = to_variable(img_scale_data)</span><br><span class="line"></span><br><span class="line">            outputs = model.forward(img)</span><br><span class="line">            bboxes, scores = model.get_pred(outputs,</span><br><span class="line">                                     im_shape=img_scale,</span><br><span class="line">                                     anchors=ANCHORS,</span><br><span class="line">                                     anchor_masks=ANCHOR_MASKS,</span><br><span class="line">                                     valid_thresh = VALID_THRESH)</span><br><span class="line"></span><br><span class="line">            bboxes_data = bboxes.numpy()</span><br><span class="line">            scores_data = scores.numpy()</span><br><span class="line">            result = multiclass_nms(bboxes_data, scores_data,</span><br><span class="line">                          score_thresh=VALID_THRESH, </span><br><span class="line">                          nms_thresh=NMS_THRESH, </span><br><span class="line">                          pre_nms_topk=NMS_TOPK, </span><br><span class="line">                          pos_nms_topk=NMS_POSK)</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(len(result)):</span><br><span class="line">                result_j = result[j]</span><br><span class="line">                img_name_j = img_name[j]</span><br><span class="line">                total_results.append([img_name_j, result_j.tolist()])</span><br><span class="line">            print(<span class="string">'processed &#123;&#125; pictures'</span>.format(len(total_results)))</span><br><span class="line"></span><br><span class="line">        print(<span class="string">''</span>)</span><br><span class="line">        json.dump(total_results, open(<span class="string">'pred_results.json'</span>, <span class="string">'w'</span>))</span><br></pre></td></tr></table></figure>

<p>json文件中保存着测试结果，是包含所有图片预测结果的list，其构成如下：</p>
<pre><code>[[img_name, [[label, score, x1, x2, y1, y2], ..., [label, score, x1, x2, y1, y2]]], 
 [img_name, [[label, score, x1, x2, y1, y2], ..., [label, score, x1, x2, y1, y2]]],
  ...
 [img_name, [[label, score, x1, x2, y1, y2],..., [label, score, x1, x2, y1, y2]]]]</code></pre><p>list中的每一个元素是一张图片的预测结果，list的总长度等于图片的数目，每张图片预测结果的格式是：</p>
<pre><code>[img_name, [[label, score, x1, x2, y1, y2],..., [label, score, x1, x2, y1, y2]]]</code></pre><p>其中第一个元素是图片名称image_name，第二个元素是包含该图片所有预测框的list， 预测框列表：</p>
<pre><code>[[label, score, x1, x2, y1, y2],..., [label, score, x1, x2, y1, y2]]</code></pre><p>预测框列表中每个元素[label, score, x1, x2, y1, y2]描述了一个预测框，label是预测框所属类别标签，score是预测框的得分；x1, x2, y1, y2对应预测框左上角坐标(x1, y1)，右下角坐标(x2, y2)。每张图片可能有很多个预测框，则将其全部放在预测框列表中。</p>
<p>在AI识虫比赛的基础版本中，老师提供了MAP指标计算代码，使用此pred_results.json文件即可计算出最终的评估指标。</p>
<h3 id="模型效果及可视化展示"><a href="#模型效果及可视化展示" class="headerlink" title="模型效果及可视化展示"></a>模型效果及可视化展示</h3><p>上面的程序展示了如何读取测试数据集的读片，并将最终结果保存在json格式的文件中。为了更直观的给读者展示模型效果，下面的程序添加了如何读取单张图片，并画出其产生的预测框。</p>
<ol>
<li>创建数据读取器以读取单张图片的数据</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 读取单张测试图片</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">single_image_data_loader</span><span class="params">(filename, test_image_size=<span class="number">608</span>, mode=<span class="string">'test'</span>)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    加载测试用的图片，测试数据没有groundtruth标签</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    batch_size= <span class="number">1</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reader</span><span class="params">()</span>:</span></span><br><span class="line">        batch_data = []</span><br><span class="line">        img_size = test_image_size</span><br><span class="line">        file_path = os.path.join(filename)</span><br><span class="line">        img = cv2.imread(file_path)</span><br><span class="line">        img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)</span><br><span class="line">        H = img.shape[<span class="number">0</span>]</span><br><span class="line">        W = img.shape[<span class="number">1</span>]</span><br><span class="line">        img = cv2.resize(img, (img_size, img_size))</span><br><span class="line"></span><br><span class="line">        mean = [<span class="number">0.485</span>, <span class="number">0.456</span>, <span class="number">0.406</span>]</span><br><span class="line">        std = [<span class="number">0.229</span>, <span class="number">0.224</span>, <span class="number">0.225</span>]</span><br><span class="line">        mean = np.array(mean).reshape((<span class="number">1</span>, <span class="number">1</span>, <span class="number">-1</span>))</span><br><span class="line">        std = np.array(std).reshape((<span class="number">1</span>, <span class="number">1</span>, <span class="number">-1</span>))</span><br><span class="line">        out_img = (img / <span class="number">255.0</span> - mean) / std</span><br><span class="line">        out_img = out_img.astype(<span class="string">'float32'</span>).transpose((<span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">        img = out_img <span class="comment">#np.transpose(out_img, (2,0,1))</span></span><br><span class="line">        im_shape = [H, W]</span><br><span class="line"></span><br><span class="line">        batch_data.append((image_name.split(<span class="string">'.'</span>)[<span class="number">0</span>], img, im_shape))</span><br><span class="line">        <span class="keyword">if</span> len(batch_data) == batch_size:</span><br><span class="line">            <span class="keyword">yield</span> make_test_array(batch_data)</span><br><span class="line">            batch_data = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> reader</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>定义绘制预测框的画图函数，代码如下。</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义画图函数</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">INSECT_NAMES = [<span class="string">'Boerner'</span>, <span class="string">'Leconte'</span>, <span class="string">'Linnaeus'</span>, </span><br><span class="line">                <span class="string">'acuminatus'</span>, <span class="string">'armandi'</span>, <span class="string">'coleoptera'</span>, <span class="string">'linnaeus'</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义画矩形框的函数 </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">draw_rectangle</span><span class="params">(currentAxis, bbox, edgecolor = <span class="string">'k'</span>, facecolor = <span class="string">'y'</span>, fill=False, linestyle=<span class="string">'-'</span>)</span>:</span></span><br><span class="line">    <span class="comment"># currentAxis，坐标轴，通过plt.gca()获取</span></span><br><span class="line">    <span class="comment"># bbox，边界框，包含四个数值的list， [x1, y1, x2, y2]</span></span><br><span class="line">    <span class="comment"># edgecolor，边框线条颜色</span></span><br><span class="line">    <span class="comment"># facecolor，填充颜色</span></span><br><span class="line">    <span class="comment"># fill, 是否填充</span></span><br><span class="line">    <span class="comment"># linestype，边框线型</span></span><br><span class="line">    <span class="comment"># patches.Rectangle需要传入左上角坐标、矩形区域的宽度、高度等参数</span></span><br><span class="line">    rect=patches.Rectangle((bbox[<span class="number">0</span>], bbox[<span class="number">1</span>]), bbox[<span class="number">2</span>]-bbox[<span class="number">0</span>]+<span class="number">1</span>, bbox[<span class="number">3</span>]-bbox[<span class="number">1</span>]+<span class="number">1</span>, linewidth=<span class="number">1</span>,</span><br><span class="line">                           edgecolor=edgecolor,facecolor=facecolor,fill=fill, linestyle=linestyle)</span><br><span class="line">    currentAxis.add_patch(rect)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义绘制预测结果的函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">draw_results</span><span class="params">(result, filename, draw_thresh=<span class="number">0.5</span>)</span>:</span></span><br><span class="line">    plt.figure(figsize=(<span class="number">10</span>, <span class="number">10</span>))</span><br><span class="line">    im = imread(filename)</span><br><span class="line">    plt.imshow(im)</span><br><span class="line">    currentAxis=plt.gca()</span><br><span class="line">    colors = [<span class="string">'r'</span>, <span class="string">'g'</span>, <span class="string">'b'</span>, <span class="string">'k'</span>, <span class="string">'y'</span>, <span class="string">'c'</span>, <span class="string">'purple'</span>]</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> result:</span><br><span class="line">        box = item[<span class="number">2</span>:<span class="number">6</span>]</span><br><span class="line">        label = int(item[<span class="number">0</span>])</span><br><span class="line">        name = INSECT_NAMES[label]</span><br><span class="line">        <span class="keyword">if</span> item[<span class="number">1</span>] &gt; draw_thresh:</span><br><span class="line">            draw_rectangle(currentAxis, box, edgecolor = colors[label])</span><br><span class="line">            plt.text(box[<span class="number">0</span>], box[<span class="number">1</span>], name, fontsize=<span class="number">12</span>, color=colors[label])</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>使用上面定义的single_image_data_loader函数读取指定的图片，输入网络并计算出预测框和得分，然后使用多分类非极大值抑制消除冗余的框。将最终结果画图展示出来。</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> paddle</span><br><span class="line"><span class="keyword">import</span> paddle.fluid <span class="keyword">as</span> fluid</span><br><span class="line"></span><br><span class="line">ANCHORS = [<span class="number">10</span>, <span class="number">13</span>, <span class="number">16</span>, <span class="number">30</span>, <span class="number">33</span>, <span class="number">23</span>, <span class="number">30</span>, <span class="number">61</span>, <span class="number">62</span>, <span class="number">45</span>, <span class="number">59</span>, <span class="number">119</span>, <span class="number">116</span>, <span class="number">90</span>, <span class="number">156</span>, <span class="number">198</span>, <span class="number">373</span>, <span class="number">326</span>]</span><br><span class="line">ANCHOR_MASKS = [[<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>], [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>], [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>]]</span><br><span class="line">VALID_THRESH = <span class="number">0.01</span></span><br><span class="line">NMS_TOPK = <span class="number">400</span></span><br><span class="line">NMS_POSK = <span class="number">100</span></span><br><span class="line">NMS_THRESH = <span class="number">0.45</span></span><br><span class="line"></span><br><span class="line">NUM_CLASSES = <span class="number">7</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    image_name = <span class="string">'/home/aistudio/work/insects/test/images/2599.jpeg'</span></span><br><span class="line">    params_file_path = <span class="string">'/home/aistudio/work/yolo_epoch50'</span></span><br><span class="line">    <span class="keyword">with</span> fluid.dygraph.guard():</span><br><span class="line">        model = YOLOv3(<span class="string">'yolov3'</span>, num_classes=NUM_CLASSES, is_train=<span class="literal">False</span>)</span><br><span class="line">        model_state_dict, _ = fluid.load_dygraph(params_file_path)</span><br><span class="line">        model.load_dict(model_state_dict)</span><br><span class="line">        model.eval()</span><br><span class="line"></span><br><span class="line">        total_results = []</span><br><span class="line">        test_loader = single_image_data_loader(image_name, mode=<span class="string">'test'</span>)</span><br><span class="line">        <span class="keyword">for</span> i, data <span class="keyword">in</span> enumerate(test_loader()):</span><br><span class="line">            img_name, img_data, img_scale_data = data</span><br><span class="line">            img = to_variable(img_data)</span><br><span class="line">            img_scale = to_variable(img_scale_data)</span><br><span class="line"></span><br><span class="line">            outputs = model.forward(img)</span><br><span class="line">            bboxes, scores = model.get_pred(outputs,</span><br><span class="line">                                     im_shape=img_scale,</span><br><span class="line">                                     anchors=ANCHORS,</span><br><span class="line">                                     anchor_masks=ANCHOR_MASKS,</span><br><span class="line">                                     valid_thresh = VALID_THRESH)</span><br><span class="line"></span><br><span class="line">            bboxes_data = bboxes.numpy()</span><br><span class="line">            scores_data = scores.numpy()</span><br><span class="line">            results = multiclass_nms(bboxes_data, scores_data,</span><br><span class="line">                          score_thresh=VALID_THRESH, </span><br><span class="line">                          nms_thresh=NMS_THRESH, </span><br><span class="line">                          pre_nms_topk=NMS_TOPK, </span><br><span class="line">                          pos_nms_topk=NMS_POSK)</span><br><span class="line"></span><br><span class="line">result = results[<span class="number">0</span>]</span><br><span class="line">draw_results(result, image_name, draw_thresh=<span class="number">0.5</span>)</span><br></pre></td></tr></table></figure>

<p><img src="output_142_0.png" alt="png"></p>
<p>通过上面的程序，清晰的给读者展示了如何使用训练好的权重，对图片进行预测并将结果可视化。最终输出的图片上，检测出了每个昆虫，标出了它们的边界框和具体类别。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>


    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
              <a href="/2019/08/03/post-title/" rel="next" title="Welcome!">
                <i class="fa fa-chevron-left"></i> Welcome!
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
              <a href="/2020/06/26/技术/inception整理/" rel="prev" title="">
                 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
    </footer>
  </div>
  
  
  
  </article>

  </div>


          </div>
          


        </div>
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Inhaltsverzeichnis
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Übersicht
          </li>
        </ul>
      

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-overview">

          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">shuzip</p>
  <div class="site-description motion-element" itemprop="description"></div>
</div>
  <nav class="site-state motion-element">
      <div class="site-state-item site-state-posts">
        
          <a href="/archives">
        
          <span class="site-state-item-count">18</span>
          <span class="site-state-item-name">Artikel</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-categories">
        
          
            <a href="/categories/">
          
        
        
        
          
        
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">Kategorien</span>
        </a>
      </div>
    
  </nav>



        </div>
      </div>
      <!--noindex-->
        <div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
            
            
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#目标检测发展历程"><span class="nav-number">1.</span> <span class="nav-text">目标检测发展历程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#目标检测基础概念"><span class="nav-number">1.1.</span> <span class="nav-text">目标检测基础概念</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#边界框（bounding-box）"><span class="nav-number">1.1.1.</span> <span class="nav-text">边界框（bounding box）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#锚框（Anchor）"><span class="nav-number">1.1.2.</span> <span class="nav-text">锚框（Anchor）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#交并比"><span class="nav-number">1.1.3.</span> <span class="nav-text">交并比</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#林业病虫害数据集和数据预处理方法介绍"><span class="nav-number">2.</span> <span class="nav-text">林业病虫害数据集和数据预处理方法介绍</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#读取AI识虫数据集标注信息"><span class="nav-number">2.1.</span> <span class="nav-text">读取AI识虫数据集标注信息</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数据读取和预处理"><span class="nav-number">2.2.</span> <span class="nav-text">数据读取和预处理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#数据读取"><span class="nav-number">2.2.1.</span> <span class="nav-text">数据读取</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数据预处理"><span class="nav-number">2.2.2.</span> <span class="nav-text">数据预处理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#随机改变亮暗、对比度和颜色等"><span class="nav-number">2.2.2.1.</span> <span class="nav-text">随机改变亮暗、对比度和颜色等</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#随机填充"><span class="nav-number">2.2.2.2.</span> <span class="nav-text">随机填充</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#随机裁剪"><span class="nav-number">2.2.2.3.</span> <span class="nav-text">随机裁剪</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#随机缩放"><span class="nav-number">2.2.2.4.</span> <span class="nav-text">随机缩放</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#随机翻转"><span class="nav-number">2.2.2.5.</span> <span class="nav-text">随机翻转</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#随机打乱真实框排列顺序"><span class="nav-number">2.2.2.6.</span> <span class="nav-text">随机打乱真实框排列顺序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#图像增广方法"><span class="nav-number">2.2.2.7.</span> <span class="nav-text">图像增广方法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#批量数据读取与加速"><span class="nav-number">2.2.3.</span> <span class="nav-text">批量数据读取与加速</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#单阶段目标检测模型YOLO-V3"><span class="nav-number">3.</span> <span class="nav-text">单阶段目标检测模型YOLO-V3</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#YOLO-V3-模型设计思想"><span class="nav-number">3.1.</span> <span class="nav-text">YOLO-V3 模型设计思想</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#产生候选区域"><span class="nav-number">3.2.</span> <span class="nav-text">产生候选区域</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#生成锚框"><span class="nav-number">3.2.1.</span> <span class="nav-text">生成锚框</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#生成预测框"><span class="nav-number">3.2.2.</span> <span class="nav-text">生成预测框</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#对候选区域进行标注"><span class="nav-number">3.2.3.</span> <span class="nav-text">对候选区域进行标注</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#标注锚框是否包含物体的objectness标签"><span class="nav-number">3.2.3.1.</span> <span class="nav-text">标注锚框是否包含物体的objectness标签</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#标注预测框的位置坐标标签"><span class="nav-number">3.2.3.2.</span> <span class="nav-text">标注预测框的位置坐标标签</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#标注锚框包含物体类别的标签"><span class="nav-number">3.2.3.3.</span> <span class="nav-text">标注锚框包含物体类别的标签</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#标注锚框的具体程序"><span class="nav-number">3.2.4.</span> <span class="nav-text">标注锚框的具体程序</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#卷积神经网络提取特征"><span class="nav-number">3.3.</span> <span class="nav-text">卷积神经网络提取特征</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#根据输出特征图计算预测框位置和类别"><span class="nav-number">3.4.</span> <span class="nav-text">根据输出特征图计算预测框位置和类别</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#建立输出特征图与预测框之间的关联"><span class="nav-number">3.4.1.</span> <span class="nav-text">建立输出特征图与预测框之间的关联</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#计算预测框是否包含物体的概率"><span class="nav-number">3.4.2.</span> <span class="nav-text">计算预测框是否包含物体的概率</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#计算预测框位置坐标"><span class="nav-number">3.4.3.</span> <span class="nav-text">计算预测框位置坐标</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#计算物体属于每个类别概率"><span class="nav-number">3.4.4.</span> <span class="nav-text">计算物体属于每个类别概率</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#损失函数"><span class="nav-number">3.5.</span> <span class="nav-text">损失函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#多尺度检测"><span class="nav-number">3.6.</span> <span class="nav-text">多尺度检测</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#开启端到端训练"><span class="nav-number">3.6.1.</span> <span class="nav-text">开启端到端训练</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#预测"><span class="nav-number">3.7.</span> <span class="nav-text">预测</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#模型效果及可视化展示"><span class="nav-number">3.7.1.</span> <span class="nav-text">模型效果及可视化展示</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </div>
      <!--/noindex-->
      

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">shuzip</span>
</div>

        








        
      </div>
    </footer>
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
      </div>

    

  </div>

  
  <script src="/lib/jquery/index.js?v=3.4.1"></script>

  <script src="/js/utils.js?v=7.3.0"></script>

  
  <script src="/js/schemes/muse.js?v=7.3.0"></script>



  
  <script src="/js/scrollspy.js?v=7.3.0"></script>
<script src="/js/post-details.js?v=7.3.0"></script>



  <script src="/js/next-boot.js?v=7.3.0"></script>

  

  

  


  




























<script>
if ($('body').find('div.pdf').length) {
  $.ajax({
    type: 'GET',
    url: '//cdn.jsdelivr.net/npm/pdfobject@2/pdfobject.min.js',
    dataType: 'script',
    cache: true,
    success: function() {
      $('body').find('div.pdf').each(function(i, o) {
        PDFObject.embed($(o).attr('target'), $(o), {
          pdfOpenParams: {
            navpanes: 0,
            toolbar: 0,
            statusbar: 0,
            pagemode: 'thumbs',
            view: 'FitH'
          },
          PDFJS_URL: '/lib/pdf/web/viewer.html',
          height: $(o).attr('height') || '500px'
        });
      });
    },
  });
}
</script>






</body>
</html>
